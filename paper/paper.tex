\documentclass[preprint]{sigplanconf}

\usepackage{siunitx}
\usepackage[color]{changebar}
\usepackage{enumitem}
\usepackage[lighttt]{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}


\usepackage{listings}
\usepackage{lmodern}
\ttfamily
\DeclareFontShape{OT1}{lmtt}{m}{it}
     {<->sub*lmtt/m/sl}{}
\lstdefinestyle{default}{language=Anglican,basicstyle=\linespread{1.0}\ttfamily, columns=flexible, showstringspaces=false}

\usepackage{hyperref}
\usepackage{url}
\usepackage{etoolbox}

\input{anglican-color}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

% Authors: comment using these commands

\newcommand*{\dt}[1]{\smallskip\noindent\fbox{\begin{minipage}{\linewidth}{\bf DT:}
        {\rm #1}\end{minipage}}}
\newcommand*{\fw}[1]{\smallskip\noindent\fbox{\begin{minipage}{\linewidth}{\bf FW:}
        {\rm #1}\end{minipage}}}
\newcommand*{\hy}[1]{\smallskip\noindent\fbox{\begin{minipage}{\linewidth}{\bf HY:}
        {\rm #1}\end{minipage}}}
\newcommand*{\jw}[1]{\smallskip\noindent\fbox{\begin{minipage}{\linewidth}{\bf JW:}
        {\rm #1}\end{minipage}}}


\cbcolor{red}
% Authors: use changebars to mark changed regions
% \cbstart
% ...
% \cbend

\title{Design and Implementation of Probabilistic Programming Language Anglican}
\authorinfo{David Tolpin \and Jan-Willem van de Meent \and Hongseok Yang \and Frank Wood}{University of Oxford}{dtolpin@robots.ox.ac.uk \and jwvdm@robots.ox.ac.uk \and hongseok.yang@cs.ox.ac.uk \and fwood@robots.ox.ac.uk}

\newtoggle{full}
\input{toggle-ifl}

\begin{document}

\maketitle

\begin{abstract}
    Anglican is a probabilistic programming system designed to interoperate
    with Clojure and other JVM languages. We introduce the
    programming language Anglican, outline our design choices,
    and discuss in depth the implementation of the Anglican language
    and runtime, including macro-based compilation, extended
    CPS-based evaluation model, and functional representations for
    probabilistic paradigms, such as a distribution,
    a random process, and an inference algorithm.
    We show that a probabilistic functional language can be
    implemented efficiently and integrated tightly with a
    conventional functional language with only moderate
    computational overhead. We also demonstrate how advanced
    probabilistic modeling concepts are mapped naturally
    to the functional foundation.
\end{abstract}

\section{Introduction}
\label{sec:intro}

For data science practitioners, statistical inference is typically
just one step in a more elaborate analysis workflow. The first stage
of this work involves data acquisition, pre-processing and cleaning.
This is often followed by several iterations of exploratory model
design and testing of inference algorithms. Once a sufficiently
robust statistical model and a corresponding inference algorithm have
been identified, analysis results must be post-processed, visualized,
and in some cases integrated into a wider production system.

Probabilistic programming systems \cite{GMR+08,MSP14,WVM14,GS15}
represent generative models as programs written in a specialized
language that provides syntax for the definition and conditioning of
random variables. The code for such models is generally concise,
modular, and easy to modify or extend. Typically inference can be
performed for any probabilistic program using one or more generic
inference techniques provided by the system backend, such as
Metropolis-Hastings \cite{WSG11,MSP14,YHG14}, Hamiltonian Monte Carlo
\cite{SDT14}, expectation propagation \cite{MWG+10}, and extensions
of Sequential Monte Carlo \cite{WVM14,MYM+15,PWD+14} methods.
These generic techniques may be less statistically efficient
than techniques tailored to a specific model. However,
probabilistic programming facilitates simpler implementations of
models making the inference inherently faster.
\jw{How exactly does probabilistic programming make inference inherently faster?}

While probabilistic programming systems shorten the iteration cycle in
exploratory model design, they typically lack basic functionality needed for
data I/O, pre-processing, and analysis and visualization of inference results.
In this paper, we describe the implementation of
Anglican~\cite{TMW15, Anglican}, a probabilistic
programming language that tightly integrates with
Clojure~\cite{H08,Clojure}, a general-purpose programming language
that runs on the Java Virtual Machine (JVM). Both languages share a common
syntax, and can be invoked from each other. This allows Anglican programs to
make use of a rich set of libraries written in both Clojure and Java.
Conversely, Anglican allows intuitive and compact specification of models for
which inference may be performed as part of a larger Clojure project.

\iftoggle{full}{%
There are several ways to build a programming language
on top of or besides another language.  The easiest is an
interpreter --- a program that reads a program, in its entirety
or line-by-line, and executes it by applying operational
semantics of a certain kind to the language. \textsc{Basic} is
famous for line-by-line interpreted implementations.

Another approach is to write a compiler, either to a virtual
architecture, so called p-code or byte-code, or to real
hardware. Here, the whole program is translated from the
`higher-level' source language to a `lower-level' object
language, which can be directly executed, either by hardware or
by an interpreter --- but the latter interpreter can be made
simpler and more efficient  than an interpreter for the source
language.

On top of these two approaches are methods in which a new
language is implemented `inside' another language of the same
level of abstraction. Different languages provide different
means for this; }{%
There are several ways to build a new language on top of an
existing one;
}%
Lisp is famous for the macro facility
that allows to extend the language almost without
restriction --- by writing \textit{macros}, one adds new
constructs to the existing language. There are several uses of
macros --- one is to extend the language \textit{syntax}, for
example, by adding new control structures; another is to keep
the existing syntax but alter the \textit{operational semantics}
--- the way programs are executed and compute their outputs.

Anglican is implemented in just this way --- a macro facility
provided by Clojure, a Lisp dialect, is used both to extend
Clojure with constructs that delimit probabilistic code, and to
alter the operational semantics of Clojure expressions inside
probabilistic code fragments. Anglican claims its right to count
as a separate language
because of the ubiquitous probabilistic
execution semantics rather than a different syntax,
which is actually an advantage rather than a drawback ---
Clojure programmers only need to know how to specify the
boundaries of Anglican programs, but can use familiar Clojure
syntax to write probabilistic code.

Inference algorithms execute Anglican programs while trying to
answer probabilistic queries on those programs. This execution is
significantly different from the one described in the standard 
operational semantics. These algorithms typically run Anglican programs 
multiple times, often hundreds of thousands or even millions of times 
for a single inference task. The algorithms may make random choices 
that do not correspond to any statements in the program, and decide which parts 
of the program code are executed and how often. Some inference algorithms 
re-run the program multiple times partially, from a certain
point on, while reusing random choices made in the previous runs as much as possible. A good high-level picture is that each inference algorithm specifies a 
virtual machine that executes Anglican programs according to a 
non-standard (usually probabilistic) operational semantics. 
Supporting a wide range of inference algorithms and their unusual semantics 
the main reason that we developed Anglican as a language rather 
than as a library. 

%An implementation of Anglican must therefore address three issues:
%\begin{itemize}
%    \item the Clojure syntax to introduce probabilistic Anglican
%        code inside Clojure modules;
%    \item source-to-source transformation of Anglican programs
%        into Clojure, so that probabilistic execution becomes
%        possible;
%    \item algorithms which run Clojure code, obtained by
%        transforming Anglican programs, according to the
%        probabilistic operational semantics.
%\end{itemize}
%Execution of probabilistic programs by inference algorithms is
%different from execution of deterministic programs.  A
%probabilistic program is executed multiple times, often hundreds
%of thousands or even millions of times for a single inference
%task. Random choices may affect which parts of the program code
%are executed and how often. Many inference algorithms require
%re-running the program multiple times partially, from a certain
%point on.  Different executions may employ different random
%choices. However, for efficient inference a correspondence
%between random choices in different executions should be
%maintained. These are just some of the challenges which were
%faced and solved during development of Anglican.

Comparisons of Anglican with other implementations of
probabilistic programming languages~\cite{SGG15}\cite[pp.
32--33]{P16} demonstrate that Anglican achieves state-of-the-art
computational efficiency without sacrificing expressiveness.
Anglican language syntax, compilation, invocation, and runtime
support of Anglican queries are discussed in detail in further
sections.

\subsection*{Contributions} This paper brings the following
major contributions:
\begin{itemize}
    \item Design and implementation of a probabilistic programming language
        Anglican involving tight bilateral integration with a general-purpose
        programming language.
    \item Techniques for efficient and compact implementation of inference
        algorithms, such as representation of inference results as a lazy
        sequence of samples and a novel scheme for addressing of checkpoints.
    \item Anglican's novel representation of random processes 
            from statistics and machine learning, such as Beta-Binomial 
            process. The representation is
            \emph{stateless} and seamlessly integrates into pure functional 
            computation. This contrasts with typical \emph{stateful}
            implementations of these processes in other probabilistic 
            programming languages.
%    \item Specification of probabilistic forms in Anglican which facilitates 
%        separation of probabilistic programs from inference algorithms.
\end{itemize}

\section{Related Work} \label{sec:related}

Efficient implementation of expressive probabilistic programming
languages has recently been an active area of
research~\cite{MMR+07,GMR+08,P09,MWG+10,MSP14,
SDT14,WVM14,GS15,GSX+16}. There is often a compromise between
the expressiveness of the language and the efficiency of
inference.  Some languages emphasize
expressiveness~\cite{MMR+07,GMR+08,MSP14,GS15}; others restrict
the class of models which can be expressed by the
language~\cite{MWG+10,SDT14,NN14} to facilitate application of
efficient inference algorithms. Anglican allows unrestricted
specification of probabilistic models in the spirit of
Church~\cite{GMR+08}, while still supporting efficient scalable
inference~\cite{WVM14,PWD+14,RNL+2016}.

Probabilistic programming languages are implemented as
interpreters~\cite{GMR+08,MSP14}, embedded
languages~\cite{P09,SGG15,GSX+16}, and compiled
languages~\cite{MMR+07,SDT14}, and also through source-to-source
transformation with augmentation~\cite{WSG11,GS15}. Each of
these methods emphasizes different priorities in language
design, such as computational efficiency, integration with an
existing development environment, ease of implementation, or
efficiency of inference. Anglican is implemented using a
combination of embedding and source-to-source transformational
compilation to combine advantages of both approaches.  CPS
transformation, employed by Anglican compiler, is also used in
WebPPL~\cite{GS15} and facilitates clean separation between
probabilistic programs and inference algorithms and diversity of
applicable inference algorithms.

Probabilistic programming languages are often implemented as
pure functional languages~\cite{GMR+08,MSP14,SGG15} in
the sense that they do not allow mutable states. This is
because reasoning about probabilistic programs and distributions
defined by the programs, as well as implementation of certain
inference algorithms~\cite{MYM+15}, is easier in such pure functional
setting. Anglican is also implemented as a language without
mutable states.  However, there are also languages which follow
imperative paradigm and support mutable state
directly~\cite{SDT14,GSX+16}, or through probabilistic
primitives~\cite{GMR+08,MSP14}. Anglican introduces a functional
alternative to stateful random primitives in the form of random
processes.

\section{Design Outline}
\label{sec:design}

An Anglican program, or \textit{query}, is compiled into a
Clojure function. When inference is performed with a provided
algorithm, this produces a sequence of samples. Anglican shares
a common syntax with Clojure; Clojure functions can be called
from Anglican code and vice versa. A simple program in Anglican
can look like the following code:
%\begin{minipage}{\linewidth}
\begin{lstlisting}[style=default]
  (defquery model "model selection" [data]
    (let [;;; Guess a distribution.
          dist (sample (categorical
                         [[normal 0.5]
                          [gamma 0.5]]))
          a (sample (gamma 1 1))
          b (sample (gamma 1 1))
          d (dist a b)]

      ;;; Observe samples from the distribution.
      (loop [observations data]
        (when (not-empty observations)
          ;; Retrieve the first observation as `o',
          ;; and store the rest of observations in 
          ;; 'observations*'.
          (let [[o & observations*] observations]
            ;; Observe 'o' from the guessed 
            ;; distribution 'd'.
            (observe d o))
          ;; Proceed to the next iteration with
          ;; the rest of observations.
          (recur observations*)))

      ;;; Return the distribution and parameters.
      [d a b]))
\end{lstlisting}
%\end{minipage}
The query builds a model for the input $\texttt{data}$, 
a sequence of data points.
It defines a probability distribution on three variables, 
$\texttt{d} \in \{\texttt{normal},\texttt{gamma}\}$
for a distribution type, and $\texttt{a}$ and $\texttt{b}$ for
positive parameters for the type. Concretely,
using the $\texttt{sample}$ forms, the query
first defines a so called prior distribution on these three variables,
and then it adjusts this prior distribution based on observations in
$\texttt{data}$ using the \texttt{observe} form.
Samples from this adapted distribution (also called posterior distribution)
can be obtained by running the query under one of Anglican's
inference algorithms.

Internally, an Anglican query is represented by a computation in
\textit{continuation passing style} (CPS)~\cite{AJ89}, and inference algorithms
exploit the CPS structure of the code to intercept probabilistic
operations in an algorithm-specific way\footnote{\cite{GS15}
also describe a CPS-based implementation of a probabilistic
programming language.}. Among the available
inference algorithms there are Particle Cascade~\cite{PWD+14},
Lightweight Metropolis-Hastings~\cite{WSG11}, Iterative Conditional
Sequential Monte-Carlo (Particle Gibbs)~\cite{WVM14}, and others.
Inference on Anglican queries generates a lazy sequence of
samples, which can be processed asynchronously in Clojure
code for analysis, integration, and decision making.

Clojure (and Anglican) runs on the JVM and gets access to a wide choice of Java
libraries for data processing, networking, presentation, and imaging.
Conversely, Anglican queries can be called from Java and other JVM languages.
Programs involving Anglican queries can be deployed as JVM
\textit{jars}, and run without modification on any platform for
which JVM is available.

A probabilistic program, or query, mostly runs deterministic
code, except for certain checkpoints, in which probabilities are
involved, and normal, linear execution of the program is
disrupted.
\iftoggle{full}{%
In Anglican and similar languages there are two types
of such checkpoints:

\begin{itemize}
    \item drawing a value from a random source (\texttt{sample});
    \item conditioning a computed value on a random source
        (\texttt{observe}).
\end{itemize}

}{%
}%
Anglican can be mostly implemented as a regular programming
language, except for the handling of these checkpoints.
\iftoggle{full}{%
Depending on the \textit{inference algorithm}, \texttt{sample}
and \texttt{observe} may result in implicit input/output
operations and control changes. For example, \texttt{observe} in
particle filtering inference algorithms \cite{WVM14} is a non-deterministic
control statement at which a particle (corresponding to
a user-level thread executing a program)
can be either replicated or terminated. Similarly, in 
Metropolis-Hastings \cite{WSG11},
\texttt{sample} is both an input
statement which `reads' values from a random source,
and a non-deterministic control statement
(with delayed effect), eventually affecting acceptance or
rejection of a sample.

}{%
}%
Because of the checkpoints, Anglican programs must allow the
inference algorithm to step in, recording information and
affecting control flow. This can be implemented through
coroutines/cooperative multitasking, and parallel execution/preemptive
multitasking, as well as through explicit
maintenance of program continuations at checkpoints. Anglican
follows the latter option.
\iftoggle{full}{%
Clojure is a functional language, and continuation-passing style
(CPS) transformation is a well-developed technique in the area
of functional languages. Implementing a variant of CPS
transformation seemed to be the most flexible and lightweight
option --- any other form of concurrency would put a higher
burden on the underlying runtime (JVM) and the operating system.
Consequently, Anglican has been implemented as a CPS-transformed
computation with access to continuations in probabilistic
checkpoints. 
}{%
}%
The Anglican `compiler'\iftoggle{full}{, represented by a set of
functions in the \texttt{anglican.trap} namespace,}{} accepts a
Clojure subset and transforms it into a variant of CPS
representation, which allows inference algorithms to intervene
in the execution flow at probabilistic checkpoints.

Anglican is intended to co-exist with Clojure and be a part of
the source of a Clojure program. To facilitate this, Anglican
programs, or queries, are wrapped by macros\iftoggle{full}{ (defined in the
\texttt{anglican.emit} namespace)}{} which call the CPS
transformations and define Clojure values suitable for passing
as arguments to inference algorithms (\texttt{defquery},
\texttt{query}). In addition to defining entire queries,
Anglican promotes modularization of inference algorithms through
the definitions of \textit{probabilistic functions} using
\texttt{defm} (Anglican counterpart of Clojure \texttt{defn}).
Probabilistic functions are
written in Anglican, may include probabilistic forms
\texttt{sample} and \texttt{observe}, and can be seamlessly
called from inside Anglican queries, just like functions locally
defined within the same query.

%Operational semantics of Anglican queries is different from that
%of Clojure code, therefore queries must be called through
%inference algorithms, rather than `directly'. 
The operational semantics of an Anglican query are different from those
of Clojure code, and are determined by an inference algorithm. Thus,
Anglican queries must be called through these inference algorithms, rather
rather than `directly'. For this purpose,
\iftoggle{full}{the
\texttt{anglican.inference} namespace}{Anglican} declares the (ad-hoc) polymorphic
function \texttt{infer} using Clojure's multimethod mechanism.
This function accepts and runs an Anglican query, 
and returns a lazy sequence of weighted samples from the
distribution defined by the query. Providing an implementation of this function
is a responsibility of the inference algorithm, which should also
override the polymorphic function \texttt{checkpoint} (defined
as a multimethod) so as to handle \texttt{sample} and
\texttt{observe} in an algorithm-specific manner and
to construct an appropriate result on the
termination of a probabilistic program.

%When inference
%is performed on an Anglican query, the query is run by a
%particular inference algorithm. Inference algorithms must
%provide an implementation for \texttt{infer}, as well as
%override the polymorphic function \texttt{checkpoint} (defined
%as a multimethod) so as to handle \texttt{sample} and
%\texttt{observe} in an algorithm-specific manner and
%to construct an appropriate result on the
%termination of a probabilistic program.

Finally, Anglican queries use `primitive', or commonly known and
used, distributions, to draw random samples and condition
observations. Many primitive distributions are provided by
\iftoggle{full}{the \texttt{anglican.runtime} namespace}{the
runtime}, and an additional distribution can be defined by the
user by implementing a particular set of functions for the
distribution (via Clojure's protocol mechanism). The
\texttt{defdist} macro provides a convenient syntax for defining
primitive distributions.

\section{Probabilistic Program}
\label{sec:pp-def}


Programs in Anglican define probability distributions 
over sequences of sampled values through their executions.

Imagine an interpreter of Anglican that runs the deterministic parts of a Anglican program 
according to its standard semantics, executes its \texttt{sample} form by
generating a random sample, and treats its $\texttt{observe}$ form by skip.
In addition to this execution, the interpreter keeps a log that records
information about all the \texttt{sample} and \texttt{observe} forms encountered 
during execution. The information kept for \texttt{sample} is a triple $(F,x,\alpha)$ of
the following data:
\begin{itemize}
        \item $F$ is one of the built-in primitive probability distributions, 
                such as the standard normal, for which we have
                the probability density or probability mass function $p_F$.
        \item $x$ is a value sampled from the distribution $F$.
        \item $\alpha$ is an address that uniquely and systematically identifies the random 
                choice made; this address is exploited in inference algorithms, as
                explained later.
\end{itemize}
The information kept for \texttt{observe} is a pair $(G,y)$ where $G$
is a primitive probability distribution as $F$ above and $y$ is an observed value.
Thus, a log is just a sequence of triples $(F,x,\alpha)$ and pairs $(G,y)$.

We call the triple part of a log \textit{trace}. This part records all the random 
choices of an execution. Thus, if the trace of a log is fixed, the rest of the log 
is decided determistically by the program. A trace induces
a sequence of pairs $(G_j, y_j)$ of distributions and values of
\textit{observed} random variables. We call this sequence an \textit{image} and
denote it by $\pmb{y}$. For notational simplicity we assume that the program
always generates the same ordered set $\pmb{z}$ of \textit{results} $z_k$.

\hy{What is $\pmb{z}$? It is not explained here. I found it easier to think
that probabilistic programs define distributions over traces.}

The target density $\pi(\vec{x}) := \gamma(\vec{x}) / Z$ of a program
is defined in terms of the product of the probabilities of all random
choices $\pmb{x}$ and the likelihood of all observations $\pmb{y}$
\begin{align}
  \gamma(\pmb{x}) 
  &:= 
  \prod_{i=1}^{\left|\pmb{x}\right|}
  p_{F_i}(x_i) \prod_{j=1}^{\left|\pmb{y}\right|}p_{G_j}(y_{j}).
  \label{eqn:p-trace}
\end{align}
The objective of inference in probabilistic program $\mathcal{P}$
is to characterize the distribution of $\pmb{z}$.

%\section{Probabilistic Program}
%\label{sec:pp-def}
%
%Anglican is a language for expressing probabilistic programs.
%A probabilistic program is a stateful \textit{deterministic} computation
%$\mathcal{P}$ with the following properties~\cite{TMP+15}:
%\begin{itemize}
%\item Initially, $\mathcal{P}$ expects no arguments.
%\item On every call, $\mathcal{P}$ returns either a distribution
%  and an address $(F,\alpha)$, a distribution and a value $(G,
%        y)$, or a value $z$.
%\item Upon returning $F$, $\mathcal{P}$ expects a value $x$ drawn from $F$ as
%    the argument to the next call (\texttt{sample} in Anglican).
%\item Upon returning $(G, y)$, $\mathcal{P}$ is invoked again
%    without arguments (\texttt{observe} in Anglican).
%\item Upon returning $z$, $\mathcal{P}$ terminates.
%\end{itemize}
%A program is run by calling $\mathcal{P}$ repeatedly until
%termination.
%
%A program need not generate the same sequence of random variables in every
%execution. For this reason we assume that each random variable $x$ is assigned
%a unique label $\alpha$, which we call an address, that induces a
%correspondence between variables in different executions. Every execution
%implicitly produces a sequence of triples of distributions, values of
%\textit{latent} random variables, and addresses, $(F_i, x_i, \alpha_i)$.  We
%call this sequence a \textit{trace} and denote it by $\pmb{x}$. A trace induces
%a sequence of pairs $(G_j, y_j)$ of distributions and values of
%\textit{observed} random variables. We call this sequence an \textit{image} and
%denote it by $\pmb{y}$. For notational simplicity we assume that the program
%always generates the same ordered set $\pmb{z}$ of \textit{results} $z_k$.
%
%The target density $\pi(\vec{x}) := \gamma(\vec{x}) / Z$ of a program
%is defined in terms of the product of the probabilities of all random
%choices $\pmb{x}$ and the likelihood of all observations $\pmb{y}$
%\begin{align}
%  \gamma(\pmb{x}) 
%  &:= 
%%  \prod_{i=1}^{\left|\pmb{x}\right|}
%  p_{F_i}(x_i) \prod_{j=1}^{\left|\pmb{y}\right|}p_{G_j}(y_{j}).
%  \label{eqn:p-trace}
%\end{align}
%The objective of inference in probabilistic program $\mathcal{P}$
%is to discover the distribution of $\pmb{z}$.

\section{Language}
\label{sec:language}

\subsection{Syntax}

The Anglican language is a subset of Clojure\footnote{It would be
possible to support almost full Clojure by expanding all macros
in the Anglican source code. However, in Clojure, unlike in
Scheme~\cite{SDF+10} or Common Lisp~\cite{PC94}, the result
of macro-expansion of derived special forms is not well
specified and implementation specific.}.  Anglican queries
are defined within \texttt{defquery}. The value of the last
expression in the query body is the result of the query.
\begin{lstlisting}[style=default]
  (defquery name doc-string? param? expr*)
\end{lstlisting}
Anglican functions outside of a query are defined using
\texttt{defm} with the same syntax as Clojure \texttt{defn},
however \texttt{name} is bound to an Anglican function.
\begin{lstlisting}[style=default]
  (defm name doc-string? [param*] expr*)
\end{lstlisting}
Within the body of \texttt{defquery} and \texttt{defm}, the
following special forms are supported, with syntax and semantics 
matching those of Clojure:
\begin{lstlisting}[style=default]
  (if test then else?)
  (when test expr*)
  (cond clause*)
  (case expr clause* default?)
  (let [binding*] expr*)
  (and expr*)
  (or expr*)
  (fn name? [param*] expr*)
  (loop [binding*] expr*)
  (recur expr*)
\end{lstlisting}
In \texttt{defquery} parameter, \texttt{let} bindings, and
\texttt{fn} argument lists, Clojure vector destructuring is
supported. Literals for atomic types and compound literals for
vectors, hash maps, and sets are supported just like in Clojure.

Clojure provides special forms \texttt{loop} and \texttt{recur}
for writing tail-recursive programs.  Anglican programs are
CPS-converted and do not use the stack; recursive calls
in Anglican cannot lead to stack overflow.  However,
\texttt{loop}/\texttt{recur} is provided in Anglican for
convenience as a way to express loops. Unlike in Clojure though,
\texttt{recur} supported only inside a \texttt{loop}.

\subsection{Core Library}
\label{sec:core}

All of Clojure's core library except for higher-order functions
(functions that accept other functions as arguments) is
available in Anglican. Higher-order functions cannot be reused
from Clojure, as they have to be re-implemented to accept
functional arguments in CPS form. The following higher-order
functions are implemented: \texttt{map}, \texttt{reduce},
\texttt{filter}, \texttt{some}, \texttt{repeatedly},
\texttt{comp}, \texttt{partial}.

\subsection{Probabilistic Forms}

In addition to re-implementing a subset of Clojure, Anglican
provides special forms for probabilistic inference:
\begin{lstlisting}[style=default]
  (sample address? distribution)
  (observe address? distribution value)
  (mem function)
  (store tag value)
  (retrieve tag)
\end{lstlisting}

\texttt{sample} and \texttt{observe} forms correspond to
handling $(F, \alpha)$ and $(G, y)$ correspondingly in the
definition of probabilistic program (Section~\ref{sec:pp-def}).
Their operational semantics can be defined in terms of
importance sampling(Equation~\ref{eqn:p-trace}): 
\begin{itemize}
    \item \texttt{sample} returns a value drawn from
        the distribution.
    \item \texttt{observe} multiplies the unnormalized
        probability of the program trace by the probability of
        drawing the value from the distribution.
\end{itemize}
However, the actual computation involved in handling of
\texttt{sample} and \texttt{observe} depends on the inference
algorithm. Different inference algorithms may treat
\texttt{sample} and \texttt{observe} differently as long as they
compute the same distribution of program results.
Denotational and operational semantics for an idealized version
of Anglican is introduced in \cite{SYH+16}; in general though,
specifying semantics of higher-order probabilistic programming
languages is an open problem.

\texttt{sample} and \texttt{observe} may appear anywhere in the
code of an Anglican program. To support these forms, the
inference engine must be able to intervene into execution of the
program, perform computations related to inference, and control
further execution of the program. This tight and complicated
interaction between the program and the inference engine
necessiates implementing Anglican as a language rather than a
library.

The remaining Anglican special forms support carrying values in
the hidden program state. \texttt{mem} implements stochastic
function  memoization (Section~\ref{sec:mem}). \texttt{store}
stores a value for a tag in the program state, which can be
later retrieved by the tag using \texttt{retrieve} during the same
program execution.

\section{Case Study}
\label{seq:study}

Before delving into implementation details, we provide a case
study of using the Anglican language and environment. This case
study takes a problem for which a solution is not immediately
obvious, \textit{the Deli dilemma}, and guides through writing
an Anglican program for the problem, executing the program, and
post-processing results. 

The program presented in this section is intentionally short and
simple. Anglican is capable of compiling and running elaborated
programs handling large amounts of data. Advanced examples of
Anglican programs and inference can be found in literature on
applications of probabilistic programming~\cite{PLW15, P16, MPT+16}.

\subsection{The Deli Dilemma}
\label{seq:deli}

Imagine that we are facing the following dilemma:
\begin{quote}
A customer wearing round sunglasses came to a deli at 1:13pm,
and grabbed a sandwich and a coffee. Later on the same day, a
customer wearing round sunglasses came at 6:09pm and ordered a
dinner.  Was it the same customer?
\end{quote}
Additionally, we know that:
\begin{itemize}
    \item There is an adjacent office quarter, and it takes
        between 5 and 15 minutes on average to walk from an
        office to the deli, where different average times are  for
        different buildings in the quarter.
    \item Depending on traffic lights, the walking time varies by about 2
        minutes.
    \item The lunch break starts at 1:00pm, and the workday ends at 6:00pm.
    \item The waiter's odds that this is the same customer are 2 to 1.
\end{itemize}

\subsection{Anglican Query}
\label{seq:deli-query}

We want to formalize the dilemma in an Anglican query, based on
the knowledge we have. Let us formalize the knowledge in
Clojure (the times are in minutes). First, we encode our prior
information which holds true independently of the customer's
visit:

\begin{lstlisting}[style=default]
  (def mean-time-to-arrive
       "average time to arrive"
       10.)
  (def sd-time-to-arrive
       "standard deviation of arrival time"
       3.)
  (def time-sd
       "walking time deviation"
       1.)
\end{lstlisting}

Then, we record our observations, based on which we want to
solve the dilemma:

\begin{lstlisting}[style=default]
  (def lunch-delay
       "time between lunch break and lunch order"
       13.)
  (def dinner-delay
       "time between end of day and dinner order"
       9.)
  (def p-same
       "prior probability of the same customer"
       (/ 2. 3.))
\end{lstlisting}


For inference, one often chooses a known distribution to
represent uncertainty. We choose the normal
distribution for representing uncertainty about average arrival
time.

\begin{lstlisting}[style=default]
  (def time-to-arrive-prior 
       "prior distribution of average arrival time"
       (normal mean-time-to-arrive
               sd-time-to-arrive))
\end{lstlisting}

There are two possibilities: either the same customer visited
the deli twice, or two different customers came to the deli,
one for lunch and the other for dinner. We define an \textbf{Anglican} function
for each case. Note that this is the first time we switch from
Clojure to Anglican. The functions must be written in Anglican
(and hence defined using \texttt{defm} instead of \texttt{defn})
because they contain probabilistic forms \texttt{sample} and
\texttt{observe}.

\begin{lstlisting}[style=default]
  (defm same-customer 
    "observe the same customer twice"
    [time-to-arrive-prior
     lunch-delay
     dinner-delay]
    (let [time-to-arrive
            (sample time-to-arrive-prior)]
      (observe (normal time-to-arrive time-sd) 
               lunch-delay)
      (observe (normal time-to-arrive time-sd)
               dinner-delay)
      [time-to-arrive]))

  (defm different-customers
    "observe different customers"
    [time-to-arrive-prior
     lunch-delay
     dinner-delay]
    (let [time-to-arrive-1
            (sample time-to-arrive-prior)
          time-to-arrive-2
            (sample time-to-arrive-prior)]
      (observe (normal time-to-arrive-1 time-sd) 
               lunch-delay)
      (observe (normal time-to-arrive-2 time-sd)
               dinner-delay)
      [time-to-arrive-1 time-to-arrive-2]))
\end{lstlisting}

Both functions have the same structure: we first `guess' the
average arrival time and then observe the actual time from a
distribution parameterized by the guessed time. However, in
\texttt{same-customer} the average arrival time is the same for
both the lunch and the dinner, while in
\texttt{different-customers} two average arrival times are
guessed independently.

We are finally ready to define the query in \textbf{Anglican}.

\begin{lstlisting}[style=default]
  (defquery deli [time-to-arrive-prior
                  lunch-delay
                  dinner-delay]
    (let [is-same-customer (sample (flip p-same))
          observe-customer (if is-same-customer
                              same-customer
                              different-customers)]
      {:same-customer is-same-customer,
       :times-to-arrive (observe-customer 
                          time-to-arrive-prior
                          lunch-delay
                          dinner-delay)}))
\end{lstlisting}

Performing inference on query \texttt{deli} computes the
probability that the same customer visited the deli twice, as
well as probability distributions of average arrival times for
both cases.

\subsection{Inference}
\label{seq:deli-inference}

Having defined the query, we are now ready to run the query
using an inference algorithm. Function
\texttt{doquery}\iftoggle{full}{ provided
by the \texttt{anglican.core} namespace}{} accepts the inference
algorithm, the query, and optional parameters, and returns a
lazy sequence of samples. We use here the inference algorithm
called Lightweight Metropolis-Hastings (LMH). The algorithm is
somewhat slow to converge but can be used with any Anglican
query, and should be robust enough for our simple problem.

We bind the results of \texttt{doquery} to variable
\texttt{samples}, to analyse the results later. However, since
the sequence is lazy, no inference is performed and no samples
are generated until they are retrieved and processed.

\begin{lstlisting}[style=default]
  (def samples (doquery :lmh deli nil))
\end{lstlisting}

To approximate the inferred distribution, we extract a finite
subsequence of samples. Many algorithms use an initial
subsequence of samples to converge to the target distribution.
Hence, we drop initial $N$ samples ($N$ is 5000 in the code
snippet below), and collect the next $N$ samples.

\begin{lstlisting}[style=default]
  (def N 5000)
  (def results (map get-result
                     (take N (drop N samples))))
\end{lstlisting}

Based on the collected samples we compute an approximation of
the posterior probability \texttt{p-same+} that the same
customer visited the deli twice.

\begin{lstlisting}[style=default]
  (def p-same+ 
       (/ (count (filter :same-customer results))
          (double N)))
\end{lstlisting}
The \texttt{:same-customer} here represents a function
that looks up the entry with the same name in a given map.
The map stores the result of a single sampled execution,
and the \texttt{:same-customer} entry in the map
records whether the same customer visits the deli in the execution.
The \texttt{filter} function in \texttt{p-same+} 
goes through all the maps in \texttt{results}
and picks only the ones whose executions involve just one customer.

With the specified observations, \texttt{p-same+} is $\approx
0.12$. The probability is much lower than the
waiter's guess \texttt{p-same} ($\frac 2 3$).
Of course, the results may vary from run to run, and, for a given
algorithm, the accuracy depends on the number of samples we
decide to retrieve. 

Besides computing the posterior probability that the same
customer visited the deli twice, we may want to know the average
time (or times) to arrive. In Bayesian inference, it is common
to report distributions instead of `most likely' values. We use
query results in retrieved samples to approximate the
distributions, and plot distribution histograms for the same
customer visiting twice (Figure~\ref{fig:dist-same}) and
two different customers (Figure~\ref{fig:dist-diff})

\begin{lstlisting}[style=default]
  ;; single customer                      
  (def time-to-arrive+ 
      (map (fn [x] (first (:times-to-arrive x)))
           (filter :same-customer results)))
  (def mean-to-arrive+ (mean time-to-arrive+))
  (def sd-to-arrive+ (std time-to-arrive+))

  ;; two customers
  (def times-to-arrive+ 
       (map :times-to-arrive 
            (filter  
              (fn [x] (not (:same-customer x)))
              results)))
  (def mean-1-to-arrive+
       (mean (map first times-to-arrive+)))
  (def sd-1-to-arrive+
       (std (map first times-to-arrive+)))
  (def mean-2-to-arrive+
       (mean (map second times-to-arrive+)))
  (def sd-2-to-arrive+
       (std (map second times-to-arrive+)))
\end{lstlisting}

In addition to plotting the distribution histograms, we use
functions \texttt{mean}, \texttt{std} provided
in the \texttt{anglican.{\linebreak[0]}stat} namespace
along with other useful statistical functions to compute
summary statistics. This is another illustration of advantage of
tight integration between Clojure and Anglican --- probabilistic
models are expressed in Anglican. However, processing of data
and results can rely on the full power of Clojure.

\begin{figure}
    \centering
    \includegraphics[trim={12pt 0 0 0},scale=0.6]{same-customer-time.pdf}
    \caption{Arrival time distribution for a single customer.}
    \label{fig:dist-same}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[trim={12pt 0 0 0},scale=0.6]{different-customers-times.pdf}
    \caption{Arrival time distributions for two customers.}
    \label{fig:dist-diff}
\end{figure}

\iftoggle{full}{%
\input{case-study-bbvb}
}{}%

This completes the case study, where we showed a probabilistic
programming solution of a problem, implemented and analysed in
Anglican and Clojure\iftoggle{full}{, using two different
inference algorithms}{}.

\section{Macro-based Compilation}
\label{sec:compilation}

Compilation of Anglican into Clojure is built around a variant of CPS
transformation. In a basic CPS-transformed program, a
continuation receives a single argument --- the computed value.
In Anglican, there are two flows of computation going in
parallel: values are computed by functional code, and,
at the same time, the state of the probabilistic program,
used by inference algorithms, is updated by
probabilistic forms. Because of that, in Anglican a continuation
accepts  \textit{two} arguments:
\begin{itemize}
    \item the computed value;
    \item the internal state, bound to the local variable
        \texttt{\$state} in every lexical scope.
\end{itemize}

The compilation relies on the Clojure \textit{macro} facility,
and implemented as a library of
\textit{functions}\iftoggle{full}{ in namespace
\texttt{anglican.trap}, which are}{} invoked by macros.  The CPS
transformation is organized in top-down manner.  The top-level
function is  \texttt{cps-of-expression}, which receives an
expression and a continuation, and returns the expression in the
CPS form. For example, the CPS transformation of constant
\texttt{1} with continuation \texttt{cont} thus takes the
following form:
\begin{lstlisting}[style=default]
  => (cps-of-expression 1 'cont)
  (cont 1 $state)
\end{lstlisting}

\subsection {The State}
\label{sec:state}

The state (\texttt{\$state}) is threaded through the computation
and contains data used by inference algorithms. \texttt{\$state}
is a Clojure hash map:
\begin{lstlisting}[style=default]
  (def initial-state
    "initial program state"
    {:log-weight 0.0,
     :result nil,
     ::mem {},
     ::store nil,
     ... })
\end{lstlisting}
which records inference-relevant information under various keys
such as $\texttt{:log-weight}$ and $\texttt{::mem}$.
The full list of map entries depends on the inference
algorithm. Except for transformation of
the \texttt{mem} form (which converts a function to one with memoization), 
CPS transformation routines
are not aware of contents of \texttt{\$state}, do not access or
modify it directly, but rather just thread the state unmodified
through the computation. Algorithm-specific handlers of
checkpoints corresponding to the probabilistic forms
(\texttt{sample}, \texttt{observe}) modify the
state and reinject a new state into the computation.

\iftoggle{full}{%
\input{expression-kinds.tex}
}{%
}%

\iftoggle{full}{%
\subsection{Implementation Highlights}
\label{seq:highlights}

So far we introduced the basics of Anglican compilation to
Clojure. The described approaches and techniques are important
for grasping the language implementation but relatively well-known.
In the rest of the section we focus on challenges we met and
resolved while implementing Anglican, as well as on
implementation of unique features of Anglican as a probabilistic
programming language.
}{%
}%

\iftoggle{full}{\subsubsection}{\subsection}{Probabilistic Forms}
\label{seq:forms}

The purpose of probabilistic forms \texttt{sample} and
\texttt{observe} is to interrupt deterministic computation and
transfer control to the inference algorithm.  Practically, this
is achieved by  returning a \textbf{checkpoint} instead of
invoking a continuation in a CPS-transformed program.  In
Clojure, checkpoints are represented by values of the
corresponding record types
(\texttt{anglican.{\linebreak[0]}trap.{\linebreak[0]}sample} or
\texttt{anglican.{\linebreak[0]}trap.{\linebreak[0]}observe}).
The types contain fields specific to each form, as well as the
continuation; calling the continuation resumes the computation.
\begin{lstlisting}[style=default]
  => (cps-of-expression '(sample dist) 'cont)
  (->sample dist cont $state)
  => (cps-of-expression '(observe dist v) 'cont)
  (->observe dist v cont $state)
\end{lstlisting}
Here \texttt{->sample} and \texttt{->observe} in the
CPS-transformed expressions are constructors for Clojure
records, and they take values of their fields as arguments.

Upon encountering a checkpoint, the inference algorithm computes
the updated program state and the value to be passed to the
continuation.  How the state is updated, the number of times the
continuation is called, and the value passed to the continuation
of \texttt{sample} depend on the inference algorithm executing
the program.  Section~\ref{sec:inference} provides more detail
on internals of inference algorithms and their interaction with
probabilistic programs.

\iftoggle{full}{%
\smallskip
\begin{center}
*\qquad*\qquad*
\end{center}

In addition to \texttt{sample} and \texttt{observe}, there are a few other special
forms ---  \texttt{store}, \texttt{retrieve}, \texttt{mem} ---
which modify program state. These forms are translated into
expressions involving calls of functions from the
\texttt{anglican.state} namespace. The \texttt{mem} form, which
implements memoization, deserves a more detailed explanation.
}{%
}%

\iftoggle{full}{\subsubsection }{\subsection}{Memoization}
\label{sec:mem}

The author of a probabilistic model might want to 
randomly draw a feature value for each entity in a collection,
but to retain the same drawn
value for the same entity during a single run of the probabilistic
program. For example, a person may have brown or green eyes
with some probability, but the \textit{same} person will
always have the same eye color. This can be achieved
through the use of memoized functions. In Anglican, one
might write:
\begin{lstlisting}[style=default]
  (let [eye-color (mem (fn [person]
                         (sample (categorical
                                   ['brown 0.5]
                                   ['green 0.5]))))]
    (if (not= (eye-color 'bill) (eye-color 'john))
      (eye-color 'bill)
      (eye-color 'john)))
\end{lstlisting}
The \texttt{mem} form converts a function to a memoized variant,
which remembers past inputs and the corresponding outputs, and 
returns the remembered output when given such a past input, 
instead of calling the original function with it. As a result,
for every input, random draws will be made only for the first time 
that the memoized function is called with the input; all subsequent
calls with the input will just reuse these draws and return the same output.

Memoization is often implemented on top of a mutable
dictionary, where the key is the argument list and the value is
the returned value. However, there are no mutable data
structures in a probabilistic program. Hence, \texttt{mem}'s
memory is stored as a nested dictionary in the program state
introduced during CPS transformation (function \texttt{mem-cps}).  
Every memoized function gets a
unique automatically generated identifier. Each time a memoized
function is called, one of two continuations is chosen,
depending on whether the same function (a function with the same
identifier) was previously called in the same run of the
probabilistic program with the same arguments. If the memoized
result is available, the continuation of the memoized function
call is immediately called with the stored result. Otherwise,
the argument of \texttt{mem} is called with a continuation which
first creates an updated state with the memoized result, and
then calls the `outer' continuation with the result and the
updated state:
\begin{lstlisting}[style=default]
  => (mem-cps '(foo))
  (let [M (gensym "M")]
    (fn mem23623 [C $state & P]
      (if (in-mem? $state M P)
        ;; previously memoized result
        (fn [] (C (get-mem $state M P) $state))
        ;; new computation
        (clojure.core/apply foo
          ;; memoize result in state
          (fn [V $state]
            (fn [] (C V (set-mem $state M P V))))
          $state P)))))
\end{lstlisting}

Memoized results are not shared among multiple runs of a
probabilistic program, which is intended. Otherwise, it would be
impossible to memoize functions with random results.

\iftoggle{full}{\subsubsection{Continuations}}{\subsection{Managing stack size}}
\label{seq:continuations}

\iftoggle{full}{
Continuations are functions that are called in tail positions
with the computed value and state as their arguments --- in CPS
there is always a function call in every tail position and never
a value. Continuations are passed to CPS transformers, and when
transformers are called recursively, the continuations are
generated on the fly.

There are two critical issues related to generation of
continuations:
\begin{itemize}
    \item unbounded \textit{stack growth} in recursive code;
    \item code size \textit{explosion} when a non-atomic
        continuation is symbolically substituted in multiple
        locations.
\end{itemize}

\paragraph{Managing stack size}
}{%
Continuations may lead to unbounded stack growth in
recursive code.
}%
In implementations of functional programming languages stack
growth is avoided through \textit{tail call optimization} (TCO).
However, Clojure does not support a general form of TCO, and
CPS-transformed code that creates deeply nested calls will
easily exhaust the stack. Anglican employs a workaround called
\textit{trampolining}~\cite{B95} --- instead of inserting a
continuation call directly, the transformer always wraps the
call into a \textit{thunk}, or parameterless function. The thunk
is returned and called by the trampoline (Clojure provides
function \texttt{trampoline} for this purpose) --- this way the
computation continues, but the stack is collapsed on every
continuation call. Function \texttt{continue} implements the
wrapping and is invoked on every continuation call:
\begin{lstlisting}[style=default]
  => (continue 'cont 'value 'state)
  (fn [] (cont value state))
\end{lstlisting}
Correspondingly, the full, wrapped CPS form of
\begin{lstlisting}[style=default]
  (fn [x y] (+ x y))
\end{lstlisting}
becomes
\begin{lstlisting}[style=default]
  (fn [cont $state x y]
    (fn []
      (cont (+ x y) $state)))
\end{lstlisting}
When the CPS-transformed function is called, it returns a
\textit{thunk} (a parameterless function) which is then
re-invoked through the trampoline, with the stack collapsed.

\iftoggle{full}{%
\input{code-explosion.tex}
}{%
}%

\iftoggle{full}{\subsubsection}{\subsection}{Primitive Procedures}
\label{seq:primitive}

When an Anglican function is transformed into a Clojure
function\iftoggle{full}{ by \texttt{fn-cps}}{}, two auxiliary
parameters are added to the beginning of the parameter list ---
continuation and state.  Correspondingly, when a function
\textit{call} is transformed\iftoggle{full}{ (by
\texttt{cps-of-application} or \texttt{cps-of-apply})}{}, the
current continuation and the state are passed to the called
function. Anglican can also call Clojure functions; however,
Clojure functions do not expect these auxiliary parameters.
To allow the mixing of Anglican (CPS-transformed) and Clojure
function calls in Anglican code, the Anglican compiler must be
able to recognize `primitive' (that is, implemented in Clojure
rather than in Anglican) functions.

Providing an explicit syntax for differentiating between
Anglican and Clojure function calls would be cumbersome. Another
option would be to use meta-data to identify Anglican function
calls at runtime. However, this would impact performance, and
good runtime performance is critical for probabilistic
programs. The approach taken by Anglican is to maintain a list
of unqualified names of primitive functions, as well of
namespaces in which all functions are primitive, and recognize
primitive functions by name --- if a function name is not in the
list, the function is an Anglican function. Global dynamically-bound 
variables \texttt{*primitive-procedures*} and
\texttt{*primitive-namespaces*} contain the initial lists of
names and namespaces, correspondingly. Of course, local bindings
can shade global primitive function names. For example,
\texttt{first} is a Clojure primitive function that takes the first
element from an ordered collection such as list and vector,
but inside the let block in the
following example, \texttt{first} is an Anglican function:
\begin{lstlisting}[style=default]
  (let [first (fn [[x & y]] x)]
    (first '[1 2 3]))
\end{lstlisting}
The Anglican compiler takes care of the shading by rebinding
\texttt{*primitive-procedures*} in every lexical
scope\iftoggle{full}{ (\texttt{fn-cps}, \texttt{cps-of-let}). Macro
\texttt{shading-primitive-procedures} automates the shading}{.}

\section{Inference Algorithms}
\label{sec:inference}

A probabilistic program in Anglican may look almost like a
Clojure program. However, the purpose of executing a
probabilistic program is different from that of a `regular'
program: instead of producing the result of a single execution,
a probabilistic program computes, exactly or approximately, the
distribution from which execution results are drawn.  Computing
the distribution is facilitated by an inference algorithm.

Probabilistic programming system Anglican provides a variety of
approximate inference algorithms. Ideally, Anglican should
automatically choose the most appropriate algorithm for each
probabilistic program. In practice, selecting an inference
algorithm, or a combination thereof, is still a challenging
task, and program structure, intended use of the computation
results, performance, approximation accuracy, and other factors
must be taken into consideration. New algorithms are being
developed and added to Anglican~\cite{TMP+15,MPT+16,RNL+2016},
as a part of ongoing research.

In the implementation of Anglican, inference algorithms are
instantiations of the (ad-hoc) polymorphic function
\texttt{infer} declared as Clojure's multimethod\iftoggle{full}{
in the \texttt{anglican.{\linebreak[0]}inference}
namespace}{}. The function accepts an algorithm identifier,
a query --- the probabilistic program in which to perform the
inference, an initial value for the query, and optional
algorithm parameters.

\subsection{The \texttt{infer} Function}
\label{sec:infer}

The sole purpose of the algorithm identifier of \texttt{infer} is to invoke
an appropriate overloading or implementation of the function --- conventionally,
the identifier is a Clojure keyword (a symbolic constant starting with colon)
related to the algorithm name, such as \texttt{:lmh} for Lightweight
Metropolis-Hastings and \texttt{:pcascade} for Particle Cascade.
The second parameter is a query as defined by
the \texttt{defquery} form or its anonymous version \texttt{query}. For instance,
the following Clojure code invokes \texttt{infer} on an Anglican query
defined anonymously via the \texttt{query} form:
\begin{lstlisting}[style=default]
  (let [x 1]
    (infer :pgibbs (query x) nil))
\end{lstlisting}
A query is executed by calling the initial continuation of the
query, which accepts a value and a state. The state is supplied
by the inference algorithm, while the value is provided as a
parameter of \texttt{infer}. A query does not have to have any
parameters, in which case the value can be simply \texttt{nil}.
When a query is defined with a binding for the initial value,
the value becomes available inside the query. A query may
accept multiple parameters using Clojure's structured binding.
For instance, it may take multiple parameters as components
of an input vector. In this case, the initial value is given
as a structured value, such as a vector, and the components
of this value are matched to the corresponding
parameters of the query via the destructuring mechanism of Clojure.
For example,
\begin{lstlisting}[style=default]
  (defquery my-query [mean sd]
    (sample (normal mean sd)))

  (def samples (infer :lmh my-query [1.0 3.0]))
\end{lstlisting}
Finally, any number of auxiliary arguments can be
passed to \texttt{infer}.
By convention, the arguments should be
keyword arguments, and are interpreted in the algorithm-specific
manner.

\subsection{Internals of an Inference Algorithm}
\label{sec:internals}

Implementing an inference algorithm in Anglican amounts to
defining an appropriate version of the \texttt{infer} function
and checkpoint handlers for \texttt{sample} and
\texttt{observe}.  The definitions may just reuse default
implementations or override them with new algorithm-specific
treatment of \texttt{sample} and \texttt{observe} forms and
inference state.

Let us illustrate this implementation step with
\textit{importance sampling},
the simplest inference algorithm.
Here is an implementation of the \texttt{infer} function for the algorithm:
\begin{lstlisting}[style=default]
  (derive ::algorithm
          :anglican.inference/algorithm)
  ;; invoked when algo parameter is :importance
  (defmethod infer :importance 
    [algo prog value & {}]
    (letfn
      ;; recursive function without any parameter
      [sample-seq 
        []
        ;; lazy infinite sequence 
        (lazy-seq
          (cons
            (:state (exec ::algorithm prog value
                          initial-state))
            (sample-seq))))]
      (sample-seq)))
\end{lstlisting}
This implementation is dispatched 
when \texttt{infer} receives \texttt{:importance} as its \texttt{algo} 
parameter. (Anglican includes multiple implementations of \texttt{infer}
for different inference algorithms.) Once dispatched, it lazily 
constructs an infinite sequence of inference states by repeatedly 
executing the program \texttt{prog} using \texttt{exec}
and retrieving the final inference state of the execution 
using \texttt{:state}. For checkpoint handlers, importance sampling simply
relies on their default implementations.
%\texttt{anglican.importance/{\linebreak[0]}infer} just calls
%\texttt{anglican.inference/{\linebreak[0]}exec} and relies on default
%implementations of checkpoint handlers. 

Typically, an inference
algorithm has its own implementations of
\texttt{checkpoint} for \texttt{sample}, \texttt{observe}, or
both, as well as invokes \texttt{exec} from an elaborated
conditional control flow. LMH (\texttt{anglican.lmh}) and SMC
(\texttt{anglican.smc}) are examples of inference algorithms
where either \texttt{observe} (SMC) or \texttt{sample} (LMH)
handler is overridden. In addition, SMC runs multiple particles
(corresponding to user-level threads) simultaneously, while LMH re-runs
programs from an intermediate continuation rather than from the
beginning.

\subsection{Addressing of Checkpoints}
\label{sec:addressing}

Many inference algorithms memoize and reuse earlier computations
at checkpoints. Variants of Metropolis-Hastings reuse previously
drawn values~\cite{WSG11}, as well as additional information
used for adaptive sampling~\cite{TMP+15} at \texttt{sample}
checkpoints. Asynchronous SMC (Particle Cascade) computes
average particle weights at \texttt{observe}
checkpoints~\cite{PWD+14}. Implementations of black-box
variational inference~\cite{WW13,MPT+16} associate with random
variables the learned parameters of variational posterior
distribution.

Checkpoints can be uniquely named at compilation time;
however, at runtime a checkpoint corresponding to a single code
location may occur multiple times due to recurrent invocation of
the function containing the checkpoint. Every unique occurrence
of a checkpoint must receive a different address. An addressing
scheme based on computing of stack addresses of checkpoints was
described in the context of Lightweight
Metropolis-Hastings~\cite{WSG11}.  This scheme has advantages
over the naive scheme where dynamic occurrences of checkpoints
are numbered sequentially. However, it impacts the
performance of probabilistic programs because of the computation
cost of computing the stack addresses:
\begin{enumerate}
    \item On every function call, a component is added to the
        address. Hence, the address size is linear in stack depth.
    \item Every function call must be augmented by symbolic
        information required to compute stack addresses.
\end{enumerate}
In addition, the above scheme can still lead to inferior
correspondence between checkpoints in different traces: in
Anglican and other probabilistic languages where distributions
are first-class objects checkpoints with incompatible arguments
can correspond to the same stack address. Consider the following
program fragment:
\begin{lstlisting}[style=default]
  (let [dist (if use-gamma
                 (gamma 2. 2.)
                 (normal 0. 1.))]
    (sample dist))
\end{lstlisting}
The \texttt{sample} checkpoint has the same stack address in
different traces. However, the random values should not be
reused between different distributions. Further on, in some
algorithms, such as black-box variational inference, the role of
checkpoint addresses is semantic rather than heuristic ---
appropriate correspondence must be established
between checkpoints in different traces for the algorithm to
work.

To overcome the above problems, Anglican introduces a new
addressing scheme which is almost as efficient as the scheme
based on stack addresses for reuse of previously drawn values,
while producing addresses of constant size, and allows manual
computation of checkpoint addresses at runtime when the default
automatic scheme is insufficient. According to the scheme:
\begin{itemize}
    \item A checkpoint may accept an auxiliary argument --- the
        checkpoint identifier. If specified, the identifier is the first
        argument of a checkpoint. For example \texttt{(sample
        'x1  (normal 0 1))} defines a \texttt{sample} checkpoint
        with identifier \texttt{x1}.
    \item If the identifier is omitted, a unique identifier is
        generated automatically as a fresh symbol.
    \item At runtime, the address of a checkpoint invocation has
        the form
        \texttt{[}\textit{checkpoint-identifier
        number-of-previous-occurrences}\texttt{]}, where the
        occurrences are of a checkpoint with the same checkpoint
        identifier.
    \item If a sequence of invocations of the same checkpoint is
        interrupted by a different checkpoint, the number of
        previous occurrences is rounded up to a multiple of
        an integer. For efficiency, a small power of 2 is used,
        such as $2^4 = 16$.
\end{itemize}

Consider the following simplified Anglican query:

\begin{lstlisting}[style=default]
  (defm foo []
    (if (sample 'C1 (flip 0.5))
      (foo)
      (bar)))

  (defm bar []
    (case (sample 'C2 (uniform-discrete 0 3))
      0 (bar)
      1 (foo)
      2 (sample 'C3 (normal 0. 1.))))

  (defquery baz
    (foo))
\end{lstlisting}

An execution of the query may result in the following
sequence of checkpoint invocations:
\begin{lstlisting}[style=default]
  (sample 'C1 ...)
  (sample 'C2 ...)
  (sample 'C2 ...)
  (sample 'C1 ...)
  (sample 'C1 ...)
  (sample 'C1 ...)
  (sample 'C2 ...)
  (sample 'C3 ...)
\end{lstlisting}
According to the addressing scheme, the addresses generated
for these invocations are
\begin{lstlisting}[style=default]
[C1 0][C2 0][C2 1][C1 16][C1 17][C1 18][C2 16][C3 0]
\end{lstlisting}
If the program is run by a Metropolis-Hastings algorithm, then a
small change usually takes place in the sequence of checkpoints
with each invocation, and the new sequence may become
\begin{lstlisting}[style=default]
  (sample 'C1 ...)
  (sample 'C2 ...)
  (sample 'C1 ...)
  (sample 'C1 ...)
  (sample 'C2 ...)
  (sample 'C2 ...)
  (sample 'C3 ...)
\end{lstlisting}
The addresses for the new sequence are
\begin{lstlisting}[style=default]
  [C1 0][C2 0][C1 16][C1 17][C2 16][C2 17][C3 0]
\end{lstlisting}
Despite the change, the correspondence between checkpoints of
similar types occurring in similar positions (relative positions
in contiguous subsequences of a certain type) is preserved, and
drawn values can be reused efficiently:

\vspace{\baselineskip}
{
\begin{tabular}{l l}
    \textbf{old} & \textbf{new} \\ \hline
    {}\texttt{[C1 0]} & \texttt{[C1 0]} \\
    {}\texttt{[C2 0]} & \texttt{[C2 0]} \\
    {}\texttt{[C2 1]} & \textit{unused} \\
    {}\texttt{[C1 16]} & \texttt{[C1 16]} \\
    {}\texttt{[C1 17]} & \texttt{[C1 17]} \\
    {}\texttt{[C1 18]} & \textit{unused} \\
    {}\texttt{[C2 16]} & \texttt{[C2 16]} \\
    \textit{missing} & \texttt{[C2 17]} \textit{drawn}\\
    {}\texttt{[C3 0]} & \texttt{[C3 0]}
\end{tabular}
\vspace{\baselineskip}}

Note that correspondence between checkpoints in different
traces plays the role of an heuristic in Metropolis-Hastings
family of algorithms. Any correspondence (or no correspondence,
meaning all values must be re-drawn from their proposal
distributions) is valid, and reused values from the previous
invocation which are not in support or have zero probability in
the new invocation are simply ignored and new values are
re-drawn.

This way, each occurrence of a checkpoint has unique address,
but small disturbances --- removal or addition of a single or just
a few checkpoints --- are unlikely to derail the entire sequence.
The probability of derailment depends on the padding. The
padding can be safely, and without any impact on performance,
set to rather large numbers. However, rounding up to a multiple
of 16 proved to be appropriate for all practical purposes.
\iftoggle{full}{%

Function \texttt{checkpoint-id} in the
\texttt{anglican.inference} namespace automates generation of
checkpoint addresses and can be used from any inference
algorithm.
}{%
}%

\section{Definitions and Runtime Library}
\label{seq:runtime}

A Clojure namespace that includes a definition of an Anglican
program imports (`requires') two essential namespaces:
\texttt{anglican.emit} and \texttt{anglican.runtime}. The former
provides macros for defining Anglican programs
(\texttt{defquery}, \texttt{query}) and functions
(\texttt{defm}, \texttt{fm}, \texttt{mem}), as well as Anglican
bootstrap definitions that must be included with every program
--- first of all, CPS implementations of higher-order functions.
\texttt{anglican.emit} can be viewed as the Anglican
\textit{compiler tool}, which helps transform Anglican code into
Clojure before any inference is performed.

\texttt{anglican.runtime} is the Anglican runtime library. For
convenience, it exposes common mathematical functions
(\texttt{abs}, \texttt{floor}, \texttt{sin}, \texttt{log},
\texttt{exp}, etc.), but most importantly, it provides
definitions of common distributions. Each distribution object implements a
distribution interface with the \texttt{sample*} and \texttt{observe*} methods;
this interface is defined using Clojure's protocol mechanism
(\texttt{anglican.{\linebreak[0]}runtime/{\linebreak[0]}distribution}).
The \texttt{sample*} \textit{method} returns a random sample and
roughly corresponds to the \texttt{sample} checkpoint,
the \texttt{observe*} \textit{method} returns the log probability
of the value and roughly corresponds to the \texttt{observe}
checkpoint. The methods can be, and sometimes are called from
handlers of the corresponding checkpoints, but do not have to
be. For example, in LMH either the \texttt{sample*} or
the \texttt{observe*} \textit{method} is called for a
\texttt{sample} checkpoint, depending on whether the value is
drawn or reused.

Macro \texttt{defdist} should be used to define distributions.
\texttt{defdist} takes care of defining a separate type
for every distribution so that Clojure multimethods (or overloaded
methods) can be dispatched on
distribution types when needed, e.g. for custom proposal distributions 
used in an inference algorithm. The
Bernoulli distribution could be defined as follows:
\begin{lstlisting}[style=default]
  (defdist bernoulli
    "Bernoulli distribution"
    [p]
    (sample* [this] (if (< (rand) p) 1 0))
    (observe* [this value]
      (Math/log (case value
                  1 p
                  0 (- 1. p)
                  0.))))
\end{lstlisting}

In addition to distributions, Anglican provides \textit{random processes},
which define sequences of random variables that are not independent and
identically distributed. Random processes are similar to the so called
`exchangeable random primitives' in Church \cite{GMR+08} and
Venture \cite{MSP14}. However, random sequences generated by Anglican random 
processes are not required to be exchangeable. Random processes are
defined using the \texttt{defproc} macro and implement the
\texttt{anglican.runtime/{\linebreak[0]}random-process} protocol. This
protocol has two methods
\begin{itemize}
\item \texttt{produce}, which returns the distribution on the next
random variable in the sequence, and
\item \texttt{absorb}, which incorporates the value for the next random
variable and returns an updated random process.
\end{itemize}
 As an example, here is a definition of a beta-Bernoulli process, in which
each random variable is distributed according to a Bernoulli distribution with
an unknown parameter that is drawn from a beta distribution:
\begin{lstlisting}[style=default]
  (defproc beta-bernoulli
    "beta-Bernoulli process"
    [a b]
    (produce [this] (bernoulli (/ a (+ a b))))
    (absorb [this x]
      (case x
        0 (beta-bernoulli a (inc b))
        1 (beta-bernoulli (inc a) b))))
\end{lstlisting}
Unlike typical implementations of exchangeable random processes,
Anglican's random processes do not have mutable state. The
\texttt{produce} and \texttt{absorb} methods are deterministic
and functional, and therefore do not have corresponding special
forms in Anglican. A sequence of random values can be generated
using a recursive loop in which \texttt{absorb} returns the
updated process for the next iteration. For example:
\begin{lstlisting}[style=default]
  (defm sample-beta-binomial [n a b]
    (loop [process (beta-bernoulli a b)
           values []]
      (if (= (count values) n)
        values
        (let [dist (produce process)
              value (sample dist)]
        (recur (absorb process value)
               (conj values value))))))
\end{lstlisting}
Similarly, random processes can also be used to recursively
observe a sequence of values:
\begin{lstlisting}[style=default]
  (loop [process (beta-bernoulli 1.0 1.0)
         [value0 & values0] values] 
    (let [dist (produce process)]
      (observe dist value0)
      (recur (absorb process value0) values0)))
\end{lstlisting}

\section{Performance}

To justify the claim that Anglican is an \textit{efficient}
implementation, performance of Anglican programs must be evaluated
both against Clojure programs and against inference tasks in
other probabilistic programming languages and environments.
Anglican passes two additional parameters to every function, adds
extra code to variable bindings, and passes every function
call through the trampoline. Hence difference in performance
between Anglican and Clojure should be most noticeable on
programs which involve many function calls. One such example is
the famous \textit{Towers of Hanoi}:

\begin{lstlisting}[style=default]
  (defn towers-of-hanoi [n from to via]
    (when (not= n 1)
        (towers-of-hanoi (dec n) from via to)
        (towers-of-hanoi (dec n) via to from)))
\end{lstlisting}

We run this program for \texttt{n} equal to 10, 15, 20, and 25. Clojure
is consistently only twice as fast as Anglican
(Table~\ref{tbl:hanoi}); considering the amount of overhead
Anglican introduces, this is a good result.
\begin{table}
    \centering
    \begin{tabular}{r|r|r|r|r}
        {\bf n}  & 10 & 15 & 20 & 25 \\ \hline
        {\bf Anglican} & 0.63 & 3.00 & 75.9 & 2381.  \\ \hline
        {\bf Clojure} &  0.32 & 1.45 & 38.1  &  1245.
    \end{tabular}
    \caption{Towers of Hanoi. Running times, in
    seconds, of Clojure and Anglican, averaged over 100 runs.
    Clojure is only twice as fast as Anglican.}
    \label{tbl:hanoi}
\end{table}

The other comparison must be made between Anglican and another
probabilistic programming environment. WebPPL~\cite{GS15} is
similar to Anglican in expressivity.  WebPPL runs on top of
\href{http://v8project.blogspot.com/}{V8}, a high performance
JavaScript engine featuring a native compiler.
Table~\ref{tbl:webppl} shows results for a few models from
\href{https://github.com/probmods/webppl}{WebPPL distribution},
as well as from
\href{https://bitbucket.org/probprog/anglican}{Anglican test
suite}. For the comparison, we re-implemented WebPPL models in
Anglican, and Anglican models in WebPPL, following as close as
possible the original implementations, and run the same
inference algorithm (called MCMC in WebPPL, LMH in Anglican)
with the same number of iterations. Anglican outperforms WebPPL
on all models. This can be attributed both to a better
transformed representation of probabilistic programs and to more
efficient architecture of the inference engine.
\begin{table}
    \centering
    \begin{tabular}{r|S[table-format=2.1]|S[table-format=2.1]}
        {\bf model}  & {\bf Anglican} & {\bf WebPPL} \\ \hline
        Latent Dirichlet allocation & 22.2 & 31.5 \\ 
        Linear regression  & 6.1 & 8.5 \\
        Logistic regression & 8.4 & 10.4 \\
        Multivariate regression & 6.9 & 14.2 \\
        Simple branching & 2.4 & 5.7 \\
        Hidden Markov model & 8.7 & 10.2
    \end{tabular}
 
    \caption{Anglican vs. WebPPL. Running times, in seconds, of
    Anglican and WebPPL, for $100\,000$ iterations of Markov Chain
    Monte Carlo (Lighweight Metropolis-Hastings), averaged over
    100 runs. Anglican outperforms WebPPL on all models.}
    \label{tbl:webppl}
\end{table}
The source code of the examples is available in the
\href{https://bitbucket.org/probprogs/anglican-white-paper}{paper
repository}.

In addition, \cite[pp. 32 -- 33]{P16} 
provides a comparison of Anglican to an older, interpreted
version of Anglican~\cite{WVM14}, and Probabilistic
Scheme~\cite{PW14} on a rather complicated inference task of
program synthesis. According to this comparison, Anglican is at
least 10 times faster than the older interpreted version, and
almost as fast as Probabilistic Scheme which uses inference
engine implemented in C. In addition, \cite[p. 171]{SGG15}
compares Anglican to a DSL for probabilistic programming in
Haskell and to Probabilistic C~\cite{PW14} on two simple
probabilistic programs. Anglican shows similar performance
to the Haskell implementation of Sequential Monte
Carlo~\cite{DFG+01} and scales better with the number of
particles. Given the simplicity of the programs used in the
evaluation, this comparison is a confirmation that the flexible
checkpoint and trampoline based interaction between an Anglican
program and the inference engine does not introduce any noticeable
overhead compared to more rigid designs.

\section{Conclusion}
\label{seq:summary}

In this paper, we presented design and implementation internals
of the \emph{probabilistic programming system} Anglican. Implementing
a language is an interesting endeavour, in particular when the
language implements a new paradigm, in this case probabilistic
programming. Functional programming is a natural complement of
probabilistic programming --- the latter allows both concise and
expressive specification of probabilistic generative models and
efficient implementation of inference algorithms.

Implementing a probabilistic language on top of and in tight
integration with a functional language, Clojure, both helped
us to accomplish an ambitious goal in a short time span, and
provided important insights on structure and semantics of
probabilistic concepts incorporated in Anglican. Computational
efficiency and expressive power of Anglican owe to adherence to
the functional approach as much as to rich inference
opportunities of the Anglican environment.

\acks

This work was partially supported under DARPA PPAML through the
U.S. AFRL under Cooperative Agreement number FA8750- 14-2-0006,
Sub Award number 61160290-111668.

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
