\documentclass[preprint]{sigplanconf}

\usepackage{enumitem}
\usepackage[lighttt]{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}

\usepackage{listings}
\usepackage[lighttt]{lmodern}
\ttfamily
\DeclareFontShape{OT1}{lmtt}{m}{it}
     {<->sub*lmtt/m/sl}{}
\lstdefinestyle{default}{language=Anglican, basicstyle=\ttfamily\small, showstringspaces=false}

\usepackage{hyperref}
\usepackage{url}

\input{anglican}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{Design and Implementation of Probabilistic Programming Language Anglican}
\authorinfo{David Tolpin \and Jan Willem van de Meent \and Hongseok Yang \and Frank Wood}{University of Oxford}{dtolpin@robots.ox.ac.uk \and jwvdm@robots.ox.ac.uk \and hongseok.yang@cs.ox.ac.uk \and fwood@robots.ox.ac.uk}

\begin{document}

\maketitle

\begin{abstract}
    Anglican is a probabilistic programming system designed to interoperate
    with Clojure and other JVM languages. We introduce the
	programming language Anglican, outline our design choices,
	and discuss in depth the implementation of the Anglican language
	and runtime, including macro-based compilation, extended
	CPS-based evaluation model, and functional representations for
	probabilistic paradigms, such as a distribution,
	a random process, and an inference algorithm.

	We show that a probabilistic functional language can be
	implemented efficiently and integrated tightly with a
	conventional functional language with only moderate
	computational overhead. We also demonstrate how advanced
	probabilistic modeling concepts are mapped naturally
	to the functional foundation.
\end{abstract}

\section{Introduction}
For data science practitioners, statistical inference is typically
but one step in a more elaborate analysis workflow. The first stage
of this work involves data acquisition, pre-processing and cleaning.
This is often followed by several iterations of exploratory model
design and testing of inference algorithms. Once a sufficiently
robust statistical model and corresponding inference algorithm have
been identified, analysis results must be post-processed, visualized,
and in some cases integrated into a wider production system.

Probabilistic programming systems \cite{GMR+08,MSP14,WVM14,GS15}
represent generative models as programs written in a specialized
language that provides syntax for the definition and conditioning of
random variables. The code for such models is generally concise,
modular, and easy to modify or extend. Typically inference can be
performed for any probabilistic program using one or more generic
inference techniques provided by the system backend, such as
Metropolis-Hastings \cite{WSG11,MSP14,YHG14}, Hamiltonian Monte Carlo
\cite{SDT04}, expectation propagation \cite{MWG+10}, and extensions
of Sequential Monte Carlo \cite{WVM14,MYM+15,PWD+14} methods.
Although these generic techniques are not always as statistically
efficient as techniques that take advantage of model-specific
optimizations, probabilistic programming makes it easier to optimize
models for a specific application in a manner that is efficient in
terms of the dimensionality of its latent variables.

While probabilistic programming systems shorten the iteration cycle in
exploratory model design, they typically lack basic functionality needed for
data I/O, pre-processing, and analysis and visualization of inference results.
In this demonstration, we describe the implementation of
Anglican~(\cite{TMW15, Anglican}), a probabilistic
programming language that tightly integrates with
Clojure~\cite{H08,Clojure}, a general-purpose programming language
that runs on the Java Virtual Machine (JVM). Both languages share a common
syntax, and can be invoked from each other. This allows Anglican programs to
make use of a rich set of libraries written in both Clojure and Java.
Conversely Anglican allows intuitive and compact specification of models for
which inference may be performed as part of a larger Clojure project.

There are several ways to build a programming language
on top or besides another language.  The easiest to grasp is an
interpreter --- a program that reads a program, in its entirety
or line-by-line, and executes it by applying operational
semantics of a certain kind to the language. \textsc{Basic} is
famous for line-by-line interpreted implementations.

Another approach is to write a compiler, either to a virtual
architecture, so called p-code or byte-code, or to real
hardware. Here, the whole program is translated from the
`higher-level' source language to a `lower-level' object
language, which can be directly executed, either by hardware or
by an interpreter --- but the latter interpreter can be made
simpler and more efficient  than an interpreter for the source
language.

On top of these two approaches are methods in which a new
language is implemented `inside' another language of the same
level of abstraction. Different languages provide different
means for this; Lisp is notorious for the macro facility
that allows to extend the language almost without
restriction --- by writing \textit{macros}, one adds new
constructs to the existing language. There are several uses of
macros --- one is to extend the language \textit{syntax}, for
example, by adding new control structures; another is to keep
the existing syntax but alter the \textit{operational semantics}
--- the way programs are executed and compute their outputs.

Anglican is implemented in just this way --- a macro facility
provided by Clojure, a Lisp dialect, is used both to extend
Clojure with constructs that delimit probabilistic code, and to
alter the operational semantics of Clojure expressions inside
probabilistic code fragments. Anglican claims its right to count
as a separate language because of the ubiquitous probabilistic
execution semantics rather than a different syntax,
which is actually an advantage rather than a drawback ---
Clojure programmers only need to know how to specify the
boundaries of Anglican programs, but can use familiar Clojure
syntax to write probabilistic code. 

An implementation of Anglican must therefore address three issues:
\begin{itemize}
    \item the Clojure syntax to introduce probabilistic Anglican
        code inside Clojure modules;
    \item source-to-source transformation of Anglican programs
        into Clojure, so that probabilistic execution becomes
        possible;
    \item algorithms which run Clojure code, obtained by
        transforming Anglican programs, according to the
        probabilistic operational semantics.
\end{itemize}

Anglican language syntax, compilation, invocation, and runtime
support of Anglican queries are discussed in detail in further
sections.

\section{Design Outline}

An Anglican program, or \textit{query}, is compiled into a Clojure
function. When inference is performed with a provided algorithm, this
produces a sequence of output values, or \textit{predicts}. Anglican
shares a common syntax with Clojure; Clojure functions can be called
from Anglican code and vice versa. A simple program in Anglican can
look like the following code:
\begin{lstlisting}[style=default]
(defquery models data
  "chooses a distribution
   which describes the data"
  (let [;; Guessing a distribution
        dist (sample (categorical
                       [[uniform-continuous 0 1]
                        [normal 0.5 1] 
                        [gamma 1 1]]))
        a (sample (gamma 1 1))
        b (sample (gamma 1 1))
        d (dist a b)]

    ;; Observing samples from the distribution
    (loop [data data]
      (when (seq data)
        (let [[x & data] data]
          (observe d x))
        (recur data)))

    ;; Predicting the distribution
    (predict :d (type d))
    (predict :a a) (predict :b b)))
\end{lstlisting}

Internally, an Anglican query is represented by a computation in
\textit{continuation passing style} (CPS)~\cite{AJ89}, and inference algorithms
exploit the CPS structure of the code to intercept probabilistic
operations in an algorithm-specific way\footnote{\cite{GS15}
also describe a CPS-based implementation of a probabilistic
programming language.}. Among the available
inference algorithms there are Particle Cascade~\cite{PWD+14},
Lightweight Metropolis-Hastings~\cite{WSG11}, Iterative Conditional
Sequential Monte-Carlo (Particle Gibbs)~\cite{WVM14}, and others.
Inference on Anglican queries generates a lazy sequence of
samples, which can be processed asynchronously in Clojure
code for analysis, integration, and decision making.

Clojure (and Anglican) run on the JVM and get access to a wide choice of Java
libraries for data processing, networking, presentation, and imaging.
Conversely, Anglican queries can be called from Java and other JVM languages.
Programs involving Anglican queries can be deployed as JVM
\textit{jars}, and run without modification on any platform for 
which JVM is available.

A probabilistic program, or query, mostly runs deterministic
code, except for certain checkpoints, in which probabilities are
involved, and normal, linear execution of the program is
disrupted. In Anglican and similar languages there are two types
of such checkpoints:

\begin{itemize}
	\item drawing a value from a random source (\texttt{sample});
    \item conditioning a computed value on a random source
        (\texttt{observe}).
\end{itemize}

Anglican can be mostly implemented as a regular programming
language, except for the handling of these checkpoints.
Depending on the \textit{inference algorithm}, \texttt{sample}
and \texttt{observe} may result in implicit input/output
operations and control changes. For example, \texttt{observe} in
particle filtering inference algorithms \cite{WVM14} a non-deterministic
control statement at which a particle can be either replicated
or terminated. Similarly, in Metropolis-Hastings \cite{WSG11},
\texttt{sample} is both an input and a non-deterministic control
statement (with delayed effect), eventually affecting acceptance
or rejection of a sample.

Because of the checkpoints, Anglican programs must allow the
inference algorithm to step in, recording information and
affecting control flow. This can be implemented through
coroutines/cooperative multitasking, parallel execution/preemptive
multitasking and shared memory, as well as through explicit
maintenance of program continuations at checkpoints. Clojure is
a functional language, and continuation-passing style (CPS)
transformation is a well-developed technique in the area of
functional languages. Implementing a variant of CPS
transformation seemed to be the most flexible and lightweight
option --- any other form of concurrency would put a higher burden
on the underlying runtime (JVM) and the operating system.
Consequently, Anglican has been implemented as a CPS-transformed
computation with access to continuations in probabilistic
checkpoints. Anglican `compiler', represented by a set of
functions in the \texttt{anglican.trap} namespace, accepts a
Clojure subset and transforms it into a variant of CPS
representation, which allows inference algorithms to intervene
in the execution flow at probabilistic checkpoints.

Anglican is intended to co-exist with Clojure and be a part of
the source of a Clojure program. To facilitate this, Anglican
programs, or queries, are wrapped by macros (defined in the
\texttt{anglican.emit} namespace), which call the CPS
transformations and define Clojure objects suitable for passing
as arguments to inference algorithms (\texttt{defquery},
\texttt{query}). In addition to defining entire queries,
Anglican promotes modularization of inference algorithms through
definition of \textit{probabilistic functions} using
\texttt{defm} and \texttt{fm} (Anglican counterparts of Clojure
\texttt{defn} and \texttt{fn}). Probabilistic functions are
written in Anglican, may include probabilistic forms
\texttt{sample} and \texttt{observe} (as well \texttt{predict}
for the output), and can be seamlessly called from inside
Anglican queries, just like functions locally defined within the
same query.

Operational semantics of Anglican queries is different from that
of Clojure code, therefore queries must be called through
inference algorithms, rather than `directly'.  The
\texttt{anglican.inference} namespace supplies the
\texttt{infer} multimethod, which accepts an Anglican query and
returns a lazy sequence of weighted samples from the
distribution defined by the query.  When inference
is performed on an Anglican query, the query is run by a
particular inference algorithm. Inference algorithms must
provide an implementation for \texttt{infer}, as well as
override some of the methods of the \texttt{checkpoint}
multimethod, called to handle \texttt{sample} and
\texttt{observe} in an algorithmic-specific manner, as well
as on termination of a probabilistic program.

Finally, Anglican queries use `primitive', or commonly known
and used, distributions, to draw random samples and condition
observations. Many primitive distributions are provided by the
\texttt{anglican.runtime} namespace, and additional
distributions can be defined by the user by implementing the
\texttt{distribution} protocol. The \texttt{defdist} macro
provides a convenient syntax for defining primitive distributions.

\section{Language}

The Anglican language is a subset of Clojure\footnote{It would be
possible to support almost full Clojure by expanding all macros
in the Anglican source code, however in Clojure, unlike in
Scheme~\cite{SDF+10}, or Common Lisp~\cite{PC94}, the result
of macro-expansion of derived special forms is not well
specified and implementation specific.}.  Within \texttt{defquery},
\texttt{let}, \texttt{if}, \texttt{when}, \texttt{cond},
\texttt{case}, \texttt{and}, \texttt{or}, \texttt{fn} forms are
supported (others may be in the future but are not now). 
In \texttt{let} bindings and \texttt{fn} argument lists,
vector destructuring (but not hash map destructuring) is
supported. Compound literals for vectors, hash maps, and
sets are supported just like in Clojure.

\subsection{\texttt{recur}}

Anglican is stackless, therefore \texttt{recur} is
unnecessary, no recursive call can lead to stack overflow;
Recursive calls to functions should be used instead. However,
\texttt{loop}/\texttt{recur} is provided for convenience as a way to express
loops. \texttt{recur} outside of \texttt{loop} will lead to unpredictable
behaviour and hard-to-catch errors.

\subsection{Core library}

All of Clojure's core library except for higher-order functions
(functions that accept other functions as arguments) is
available in Anglican. Higher-order functions cannot be reused
from Clojure, they have to be re-implemented to accept
functional arguments in CPS form. The following higher-order
functions are implemented: \texttt{map}, \texttt{reduce},
\texttt{filter}, \texttt{some}, \texttt{repeatedly},
\texttt{comp}, \texttt{partial}.

\section{Macro-based Compilation}

Compilation of Anglican into Clojure relies on the Clojure
\textit{macro} facility. However, the compilation algorithm is
implemented as a library of \textit{functions} in namespace
\texttt{anglican.trap}, which are invoked by macros.
The CPS transformation is organized in top-down manner. The
top-level function is  \texttt{cps-of-expression}, which
receives an expression and a continuation, and returns the
expression in the CPS form, with the computed result passed to
the continuation. A continuation accepts \textit{two} arguments:
\begin{itemize}
    \item the computed value;
    \item the internal state, bound to the local variable
        \texttt{\$state} in every lexical scope.
\end{itemize}
The CPS transformation of constant \texttt{1} with continuation
\texttt{cont} thus takes the following form:
\begin{lstlisting}[style=default]
=> (cps-of-expression 1 'cont)
(cont 1 $state)
\end{lstlisting}

The state (\texttt{\$state}) is threaded through the computation
and contains data used by inference algorithm. \texttt{\$state}
is a Clojure hash map:
\begin{lstlisting}[style=default]
(def initial-state
  "initial program state"
  {:log-weight 0.0
   :predicts []
   :result nil
   ::mem {}
   ::store nil
   ... })
\end{lstlisting}
The full list of map entries depends on the inference
algorithm. Except for transformation of
\texttt{mem}, the memoization form, CPS transformation routines
are not aware of contents of \texttt{\$state}, do not access or
modify it directly, but rather just thread the state unmodified
through the computation. Algorithm-specific handlers of
checkpoints corresponding to the probabilistic forms
(\texttt{sample}, \texttt{observe}) modify the
state and reinject a new state into the computation.

\subsection{Expression Kinds}

There are three different kinds of inputs to CPS transformation:
\begin{itemize}
    \item literals, which are passed as an argument to the
        continuation unmodified;
    \item value expressions (e.g. the \texttt{fn} form) 
        (called \textit{opaque}
        expressions in the code) which must be transformed to
        CPS, but the transformed object is passed to the
        continuation as a whole, opaquely;
    \item general expressions (let's call them
        \textit{transparent}), through which the continuation is
        threaded in an expression-specific way, and can be
        called in multiple locations of the CPS-transformed
        code, such as in all branches of an \texttt{if}
        statement.
\end{itemize}

\subsubsection{Literals}

Literals are the same in Anglican and Clojure. They are 
left unmodified; literals are a subset of opaque expressions.
However, the Clojure syntax has a peculiarity
of using the syntax of compound literals (vectors, hash maps,
and sets) for data constructors. Hence, compound literals must
be traversed recursively, and if there is a nested non-literal
component, transformed into a call to the corresponding data
constructor. Functions \texttt{cps-of-vector},
\texttt{cps-of-hash-map}, \texttt{cps-of-set}, called from
\texttt{cps-of-expression}, transform Clojure constructor syntax
(\texttt{[...]}, \texttt{\{...\}}, \texttt{\#\{...\}}) into the
corresponding calls:
\begin{lstlisting}[style=default]
=> (cps-of-vector [0 1 2] 'cont)
(cont (vector 0 1 2) $state)
=> (cps-of-hash-map {:a 1 :b 2} 'cont)
(cont (hash-map :a 1, :b 2) $state)
=> (cps-of-set #{0 1} 'cont)
(cont (set (list 0 1)) $state)
\end{lstlisting}

\subsubsection{Opaque Expressions}

Opaque, or value, expressions, have a different shape in the
original and the CPS form. However, their CPS form follows the
pattern \texttt{(continuation transformed-expression)}, and thus
the transformation does not depend on the continuation, and
can be accomplished without passing the continuation as a
transformation argument. Primitive (non-CPS) procedures used in
Anglican code, \texttt{(fn ...)} forms, and \text{(mem ...)}
forms are opaque and transformed by
\texttt{primitive-}\linebreak[0]\texttt{procedure-}\linebreak[0]\texttt{cps},
\texttt{fn-cps}, and \texttt{mem-cps}, correspondingly: a
slightly simplified CPS form of expression
\begin{lstlisting}[style=default]
(fn [x y]
  (+ x y))
\end{lstlisting}
would be
\begin{lstlisting}[style=default]
(fn [cont $state x y] 
  (cont (+ x y) $state))
\end{lstlisting}
In the actual code an automatically generated fresh symbol is
used instead of \texttt{cont}.

\subsubsection{General Expressions}

The most general form of CPS transformation receives an
expression and a continuation, and returns the expression
in CPS form with the continuation potentially called in multiple
tail positions. General expressions can be somewhat voluntarily
divided into several groups:
\begin{itemize}
    \item binding forms --- \texttt{let} and
        \texttt{loop/recur};
    \item flow control --- \texttt{if}, \texttt{when},
        \texttt{cond}, \texttt{case}, \texttt{and}, \texttt{or} and \texttt{do};
    \item function applications and \texttt{apply};
    \item probabilistic forms --- \texttt{predict},
        \texttt{observe}, \texttt{sample}, \texttt{store}, and \texttt{retrieve}.
\end{itemize}
Functions that transform general expressions accept the
expression and the continuation as parameters, and are
consistently named \texttt{cps-of-}\textit{form}, for example,
\texttt{cps-of-do}, \texttt{cps-of-store}.

\subsection{Implementation Highlights}

\subsubsection{Continuations}

Continuations are functions that are called in tail positions
with the computed value and state as their arguments --- in CPS
there is always a function call in every tail position and never
a value. Continuations are passed to CPS transformers, and when
transformers are called recursively, the continuations are
generated on the fly. 

There are two critical issues related to generation of
continuations:
\begin{itemize}
    \item unbounded \textit{stack growth} in recursive code;
    \item code size \textit{explosion} when a non-atomic
        continuation is symbolically substituted in multiple
        locations.
\end{itemize}
        
\paragraph{Managing stack size}

In implementations of functional programming languages stack
growth is avoided through \textit{tail call optimization} (TCO).
However, Clojure does not support a general form of TCO, and
CPS-transformed code that creates deeply nested calls will
easily exhaust the stack. Anglican employs a workaround called
\textit{trampolining} --- instead of inserting a continuation
call directly, the transformer always wraps the call into a
\textit{thunk}, or parameterless function. The thunk is returned
and called by the trampoline (Clojure provides function
\texttt{trampoline} for this purpose) --- this way the
computation continues, but the stack is collapsed on every
continuation call. Function \texttt{continue} implements the
wrapping and is invoked on every continuation call:
\begin{lstlisting}[style=default]
=> (continue 'cont 'value 'state)
(fn [] (cont value state))
\end{lstlisting}
Correspondingly, the full, wrapped CPS form of
\begin{lstlisting}[style=default]
(fn [x y] (+ x y))
\end{lstlisting}
becomes
\begin{lstlisting}[style=default]
(fn [cont $state x y] 
  (fn [] 
    (cont (+ x y) $state)))
\end{lstlisting}
When the CPS-transformed function is called, it returns a
\textit{thunk} (a parameterless function) which is then
re-invoked through the trampoline, with the stack collapsed.

\paragraph{Avoiding exponential code growth}

To realize potential danger of code size explosion, consider
CPS transformation of code
\begin{lstlisting}[style=default]
(if (adult? person)
  (if (male? person)
     (choose-beer)
     (choose-wine))
  (choose-juice))
\end{lstlisting}
with continuation 
\begin{lstlisting}[style=default]
(fn [choice _]
  (case (kind choice)
    :beer (beer-jar choice)
    :wine (wine-glass choice)
    :juice (juice-bottle choice)))
\end{lstlisting}
The code of the continuation, represented by the \texttt{fn}
form, will be repeated three times. In general, CPS code can
grow extremely large if symbolic continuations are inserted
repeatedly.

To circumvent this inefficiency, CPS transformers for
expressions with multiple continuation points (\texttt{if} and
derivatives, \texttt{and}, \texttt{or}, and \texttt{case}) bind
the continuation to a fresh symbol if it is not yet a symbol.
Macro \texttt{defn-with-{\linebreak[0]}named-{\linebreak[0]}cont}
establishes the binding automatically:
\begin{lstlisting}[style=default]
=> (cps-of-if '(c t f) '(fn [x] (* 2 x)))
(let [cont (fn [x] (* 2 x))]
  (if c
      (fn [] (cont t $state))
      (fn [] (cont f $state))))
\end{lstlisting}

\subsubsection{Primitive Procedures}

When an Anglican function is transformed into a Clojure function
by \texttt{fn-cps}, two auxiliary parameters are added to the
beginning of the parameter list --- continuation and state.
Correspondingly, when a function \textit{call} is transformed
(by \texttt{cps-of-application} or \texttt{cps-of-apply}), the
current continuation and the state are passed to the called
function. Anglican can also call Clojure functions; however
Clojure functions do not expect these auxiliary parameters.
To allow the mixing of Anglican (CPS-transformed) and Clojure
function calls in Anglican code, the Anglican compiler must be
able to recognize `primitive' (that is, implemented in Clojure
rather than in Anglican) functions. 

Providing an explicit syntax for differentiating between
Anglican and Clojure function calls would be cumbersome. Another
option would be to use meta-data to identify Anglican function
calls at runtime, however this would impact performance, and
a good runtime performance is critical for probabilistic
programs. The approach taken by Anglican is to maintain a list
of unqualified names of primitive functions, as well of
namespaces in which all functions are primitive, and recognize
primitive functions by name --- if a function name is not in the
list, the function is an Anglican function. Global dynamically
bound variables \texttt{*primitive-procedures*} and
\texttt{*primitive-namespaces*} contain the initial lists of
names and namespaces, correspondingly. Of course, local bindings
can shade global primitive function names. For example,
\texttt{first} is an Anglican function inside the let block in the
following example:
\begin{lstlisting}[style=default]
(let [first (fn [[x & y]] x)]
  (first '[1 2 3]))
\end{lstlisting}
The Anglican compiler takes care of the shading by rebinding
\texttt{*primitive-procedures*} in every lexical scope
(\texttt{fn-cps}, \texttt{cps-of-let}). Macro
\texttt{shading-primitive-procedures} automates the shading.

\subsubsection{Probabilistic forms}

There are two proper probabilistic forms turning Anglican into a
probabilistic programming language --- \texttt{sample} and
\texttt{observe}. Their purpose is to interrupt deterministic
computation and transfer control to the inference algorithm.
Practically, this is achieved through returning
\textbf{checkpoints} --- Clojure records of the corresponding
types (\texttt{anglican.trap.sample} or
\texttt{anglican.trap.observe}). The records contain fields
specific to each form, as well as the continuation; calling the
continuation resumes the computation. Checkpoints expose the
program state to the inference algorithm, and the updated state
is re-injected into the computation when the continuation is
called: 
\begin{lstlisting}[style=default]
=> (cps-of-expression '(sample dist) 'cont)
(->sample dist cont $state)
=> (cps-of-expression '(observe dist val) 'cont)
(->observe dist val cont $state)
\end{lstlisting}

In addition to checkpoints, there are a few other special forms
--- \texttt{predict}, \texttt{store}, \texttt{retrieve},
\texttt{mem} --- which modify program state. These forms are
translated into expressions involving calls of functions from the
\texttt{anglican.state} namespace. The \texttt{mem} form, which
implements stochastic memoization, deserves a more detailed
explanation.

\textbf{Memoization} is often implemented on top of a mutable
dictionary, where the key is the argument list and the value is
the returned value. However, there are no mutable data
structures in a probabilistic program, hence \texttt{mem}'s
memory is stored as a nested dictionary in the program state
(function \texttt{mem-cps}).  Every memoized function gets a
unique automatically generated identifier. Each time a memoized
function is called, one of two continuations is chosen,
depending on whether the same function (a function with the same
identifier) was previously called in the same run of the
probabilistic program with the same arguments. If the memoized
result is available, the continuation of the memoized function
call is immediately called with the stored result. Otherwise,
the argument of \texttt{mem} is called with a continuation which
first creates an updated state with the memoized result, and
then calls the `outer' continuation with the result and the
updated state:
\begin{lstlisting}[style=default]
=> (mem-cps '(foo))
(let [M (gensym "M")]
  (fn mem23623 [C $state & P]
    (if (in-mem? $state M P)
      ;; previously memoized result
      (fn []
        (C (get-mem $state M P) $state))
      ;; new computation
      (clojure.core/apply
        foo
        ;; memoize result in continuation
        (fn [V $state]
          (fn [] (C V (set-mem $state M P V))))
        $state
        P)))))
\end{lstlisting}

Memoized results are not shared among multiple runs of a
probabilistic program, which is intended. Otherwise, it would be
impossible to memoize functions with random results.

\section{Inference Algorithms}

An inference algorithm is an implementation of \texttt{infer}
multimethod from \texttt{anglican.inference} namespace. The
multimethod accepts an algorithm identifier, a query --- the
probabilistic program in which to perform the inference, an
initial value for the query, and optional algorithm parameters.

\subsection{The \texttt{infer} multimethod}

The sole purpose of the algorithm identifier is method dispatch
--- conventionally, the identifier is a keyword related to the
algorithm name (\texttt{:lmh} for Lightweight
Metropolis-Hasting, \texttt{:pcascade} for Particle Cascade
etc.). The second parameter is a query as defined by
\texttt{query} or \texttt{defquery} forms. If needed, the query
can be defined anonymously, right in the argument list of a call
to \texttt{infer}:
\begin{lstlisting}[style=default]
(let [x 1]
  (infer :pgibbs (query (predict x)) nil))
\end{lstlisting}
A query is executed by calling the initial continuation of the
query, which accepts a value and a state. The state is supplied
by the inference algorithm, however the value is provided as a
parameter of \texttt{infer}. A query does not have to have any
parameters, in which case the value can be simply \texttt{nil}.
When a query is defined with a binding for the initial value,
the value becomes available inside the query. The value is
destructured in case of a structured binding, for example:
\begin{lstlisting}[style=default]
(defquery my-query [mean sd]
  (predict (sample (normal mean sd))))

(def samples (infer :lmh my-query [1.0 3.0]))
\end{lstlisting}
Finally, an indefinite number of auxiliary arguments can be
passed to \texttt{infer}. By convention, the arguments should be
keyword arguments, and are interpreted in the algorithm-specific
manner.

\subsection{Internals of an inference algorithm}

The simplest inference algorithm is \textit{importance
sampling}:
\begin{lstlisting}[style=default]
(derive ::algorithm
        :anglican.inference/algorithm)
(defmethod infer :importance [_ prog value & {}]
  (letfn
    [(sample-seq []
       (lazy-seq
         (cons
           (:state (exec ::algorithm prog value
                         initial-state))
           (sample-seq))))]
    (sample-seq)))
\end{lstlisting}
\texttt{anglican.importance/{\linebreak[0]}infer} just calls
\texttt{anglican.inference/{\linebreak[0]}exec} and relies on default
implementations of checkpoint handlers. A different inference
algorithm would provide its own implementations of
\texttt{checkpoint} for \texttt{sample}, \texttt{observe}, or
both, as well as invoke \texttt{exec} from an elaborated
conditional control flow. LMH (\texttt{anglican.lmh}) and SMC
(\texttt{anglican.smc}) are examples of inference algorithms
where either \texttt{observe} (SMC) or \texttt{sample} (LMH)
handler is overridden. In addition, SMC runs multiple particles
(program instances) simultaneously, while LMH runs re-runs
programs from an intermediate continuation rather than from the
beginning.

\section{Definitions and Runtime Library}

A Clojure namespace that includes a definition of an Anglican
program imports (`requires') two essential namespaces:
\texttt{anglican.emit} and \texttt{anglican.runtime}. The former
provides macros for defining Anglican programs
(\texttt{defquery}, \texttt{query}) and functions
(\texttt{defm}, \texttt{fm}, \texttt{mem}), as well as Anglican
bootstrap definitions that must be included with every program
--- first of all, CPS implementations of higher-order functions.
\texttt{anglican.emit} can be viewed as the Anglican
\textit{compiler tool}, which helps transform Anglican code into
Clojure before any inference is performed.

\texttt{anglican.runtime} is the Anglican runtime library. For
convenience, it exposes common mathematical functions
(\texttt{abs}, \texttt{floor}, \texttt{sin}, \texttt{log},
\texttt{exp}, etc.), but most importantly, it provides
definitions of common distributions. Each distribution object
implements the \texttt{anglican.{\linebreak[0]}runtime/{\linebreak[0]}distribution} protocol,
with two methods: \texttt{sample*} and \texttt{observe*}.
The \texttt{sample*} \textit{method} returns a random sample and
roughly corresponds to the \texttt{sample} checkpoint,
the \texttt{observe*} \textit{method} returns the log probability
of the value and roughly corresponds to the \texttt{observe}
checkpoint. The methods can be, and sometimes are called from
handlers of the corresponding checkpoints, but do not have to
be. For example, in LMH either the \texttt{sample*} or
the \texttt{observe*} \textit{method} is called for a
\texttt{sample} checkpoint, depending on whether the value is
drawn or re-used. 

Macro \texttt{defdist} should be used to define distributions.
\texttt{defdist} takes care of defining a separate record type
for every distribution so that multimethods can be dispatched on
distribution types when needed, e.g. for custom proposals. The
Bernoulli distribution could be defined as follows:
\begin{lstlisting}[style=default]
(defdist bernoulli
  "Bernoulli distribution"
  [p]
  (sample* [this] (if (< (rand) p) 1 0))
  (observe* [this value]
    (Math/log (case value
                1 p
                0 (- 1. p)
                0.))))
\end{lstlisting}

Similar to distributions, \textit{random processes}, related to
so called `exchangeable random procedures'\footnote{However, random sequences
generated by Anglican random processes are not required to be
exchangeable.}, are defined using
macro \texttt{defproc} and implement the
\texttt{anglican.runtime/{\linebreak[0]}random-process} protocol. The protocol
has two methods --- \texttt{produce}, which returns a
distribution object, and \texttt{absorb}, which returns a new
random process object obtained by absorbing a value drawn from
the process. Here is a definition of the Poisson process:
\begin{lstlisting}[style=default]
(defproc PP
  "Poisson point process"
  [rate] [dist (exponential rate)]
  (produce [this] dist)
  (absorb [this value] this))
\end{lstlisting}
While distributions are random and non-functional,
random processes are deterministic and functional, hence
\texttt{produce} and \texttt{absorb} are called directly and do
not have corresponding special forms in Anglican: 
\begin{itemize}
    \item Values produced by the process are sampled from the distribution
        returned by \texttt{produce}.
    \item When a value is observed from the distribution, a new
        process, with the observed value absorbed, is returned
        by \texttt{absorb}.
\end{itemize}
A common pattern of programming with processes in Anglican is
recursively computing a new process based on the observed value:
\begin{lstlisting}[style=default]
(loop [process (HawkesPointProcess)
       [value & values] values]
  (let [dist (produce process)]
    (observe dist value)
    (recur (absorb process value) values)))
\end{lstlisting}
Unlike conventional implementations of random processes,
Anglican's random processes do not have mutable state.

\section{Summary}

In this paper, we presented design and implementation internals
of the Probabilistic Programming System Anglican. Implementing
a language is an interesting endeavour, in particular when the
language implements a new paradigm, in this case probabilistic
programming. Functional programming is a natural complement of
probabilistic programming --- the latter allows both concise and
expressive specification of probabilistic generative models and
efficient implementation of inference algorithm.

Implementing a probabilistic language on top and in tight
integration with a functional language, Clojure, both helped
us to accomplish an ambitious goal in a short time span, and
provided important insights on structure and semantics of
probabilistic concepts incorporated in Anglican. Efficiency
and expressive power of Anglican owe to adherence to the
functional approach as much as to rich inference opportunities
of the Anglican environment.

\acks

This work was partially supported under DARPA PPAML through the
U.S. AFRL under Cooperative Agreement number FA8750- 14-2-0006,
Sub Award number 61160290-111668.

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
