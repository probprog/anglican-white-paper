(m! -h)
(doc split-with)
(require '[clojure.string :as str])
(doc str/split)
(split "a b " " ")
(str/split "a b " " ")
#" "
(str/split "a b " #" ")
(use 'anglican.runtime)
(dirichlet (repeat 10 1))
(def x (dirichlet (repeat 10 1)))
(sample x)
(sample* x)
(doc enumerate)
(enumerate)
(doc enumeration-seq)
(doc range)
(take 10 (range))
(into {} (map (->[#_ #_]) ["a" "b"] (range)))
(into {} (map (->[@_ @_]) ["a" "b"] (range
))
)
(into {} (map (->[% %]) ["a" "b"] (range)))
(into {} (map #(->[% %]) ["a" "b"] (range)))
(into {} (map #(->[%1 %2]) ["a" "b"] (range)))
(doc discrete)
(use 'anglican.runtime)
(doc discrete)
(keys {:x 1 :y 2})
(items {:x 1 :y 2})
(seq {:x 1 :y 2})
(m! -h
)
(m! -a lmh -n 10 -b 10 lda)
(m! -a lmh -n 10 -b 10 -d lda)
(m! -a lmh -n 10 -b 10 lda)
(m! -a lmh -n 10 -b 10 template)
(m! -a lmh -n 10 -b 10 lda)
(m! -a lmh -n 10 -b 10 lda -d)
(m! -a lmh -n 10 -b 10 lda)
(m! -a lmh -n 100 -b 1000 lda)
(time (m! -a lmh -n 100 -b 1000 lda))
(time (m! -a lmh -n 100 -b 10000 lda))
(time (m! -a lmh -n 100 -b 100000 lda))
(time (m! -a lmh -n 100 -b 10000 lda))
(time (m! -a almh -n 100 -b 10000 lda))
(time (m! -a lmh -n 1 -b 10000 lda))
(time (m! -a lmh -n 1 -b 20000 lda))
(time (m! -a lmh -n 1 -b 100000 lda))
(doc time)
(time (m! -a lmh -n 1 -b 100000 lda))
(gc)
(time (m! -a lmh -n 1 -b 100000 lda))
(time (m! -a lmh -n 1 -b 10 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 lda))
(System/gc)
(time (m! -a lmh -n 1 -b 100000 lda))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 10000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 lda))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 1000 linearRegression))
(time (m! -a lmh -n 1 -b 1000 logisticRegression))
(require 
(require 'logisticRegression)
(require 'linearRegression)
(time (m! -a lmh -n 1 -b 1000 linearRegression))
(time (m! -a lmh -n 1 -b 100000 linearRegression))
(require '[clojure.core.matrix :as m])
(m/diagonal 2)
(m/diagonal [2])
(m/diagonal [1 1])
(m/diagonal [2 2])
(m/diagonal)
(doc m/diagonal)
(m/identity-matrix 2)
(require '[anglican.runtime :as a])
(sample* (a/mvn [0 0] [[1 0] [ 0 1]]))
(a/sample* (a/mvn [0 0] [[1 0] [ 0 1]]))
(doc m/vec?)
(doc m/matrix)
(doc m/array)
(m/zero-vector 2)
(doc m/mul)
(doc m/mmul)
(m/mmul (m/identity-matrix 2) (m/zeros 2))
(m/mmul (m/identity-matrix 2) (m/zero-vector 2))
(m/vector 2)
(m/vector [1 2])
(m/array [1 2])
(doc mapv)
(doc m/esum)
(time (m! -a lmh -n 1 -b 1000 linearRegression))
(time (m! -a lmh -n 1 -b 100000 linearRegression))
(time (m! -a lmh -n 1 -b 1000 multivariateRegression))
(time (m! -a lmh -n 1 -b 100000 multivariateRegression))
(m! -h)
(time (m! -a lmh -n 1 -b 10000 multivariateRegression))
(time (m! -a lmh -n 1 -b 100000 multivariateRegression))
(time (m! -a lmh -n 1 -b 100000 linearRegression))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 linearRegression))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 multivariateRegression))
(time (m! -a lmh -n 1 -b 100000 branching))
(time (m! -a lmh -n 1 -b 1000 hmm))
(time (m! -a lmh -n 1 -b 100000 hmm))
(time (m! -a lmh -n 1 -b 100000 branching))
(time (m! -a lmh -n 1 -b 100000 multivariateRegression))
(time (m! -a lmh -n 1 -b 100000 linearRegression))
(time (m! -a lmh -n 1 -b 100000 logisticRegression))
(time (m! -a lmh -n 1 -b 100000 bernoulli))
(time (m! -a lmh -n 1 -b 100000 branching))
(time (m! -a lmh -n 1 -b 500000 branching))
(/ 10627 5)
(/ 10627 5.)
(/ 23.297 5.)
(time (m! -a lmh -n 1 -b 100000 hmm))
(time (m! -a lmh -n 1 -b 1000000 hmm))
